<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SAX解析XML]]></title>
    <url>%2F2019%2F04%2F24%2FSAX%E8%A7%A3%E6%9E%90XML%2F</url>
    <content type="text"><![CDATA[自定义解析XML并测试Servlet待解析的XML文件 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;login&lt;/servlet-name&gt; &lt;servlet-class&gt;SAX.LoginServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;login&lt;/servlet-name&gt; &lt;url-pattern&gt;/g&lt;/url-pattern&gt; &lt;url-pattern&gt;/login&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;reg&lt;/servlet-name&gt; &lt;servlet-class&gt;SAX.RegisterServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;reg&lt;/servlet-name&gt; &lt;url-pattern&gt;/reg&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 根据XML创建类 123456789101112131415161718192021222324package SAX;//Entity对应XML中的servletpublic class Entity &#123; private String name; //对应servlet-name private String clz; //对应servlet-class public Entity()&#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getClz() &#123; return clz; &#125; public void setClz(String clz) &#123; this.clz = clz; &#125;&#125; 123456789101112131415161718192021222324252627282930313233package SAX;import java.util.HashSet;import java.util.Set;//Mapping类对应XML中的serlvet-mappingpublic class Mapping &#123; private String name; private Set&lt;String&gt; patterns; public Mapping()&#123; patterns = new HashSet&lt;&gt;(); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Set&lt;String&gt; getPatterns() &#123; return patterns; &#125; public void setPatterns(Set&lt;String&gt; patterns) &#123; this.patterns = patterns; &#125; public void addPattren(String pattern)&#123; this.patterns.add(pattern); &#125;&#125; 编写上下文处理器完成由url-pattern—&gt;servlet-name—-&gt;servlet-class的映射 12345678910111213141516171819202122232425262728293031323334353637package SAX;import java.util.HashMap;import java.util.List;import java.util.Map;public class WebContext &#123; private List&lt;Entity&gt; entities; private List&lt;Mapping&gt; mappings; private Map&lt;String,String&gt; entitymap = new HashMap&lt;&gt;(); private Map&lt;String,String&gt; mappingmap = new HashMap&lt;&gt;(); public WebContext(List&lt;Entity&gt; entities, List&lt;Mapping&gt; mappings) &#123; this.entities = entities; this.mappings = mappings; //将entities转换成servlet-name --&gt;servlet-class的映射存放到entitymap中 for (Entity entity : entities) &#123; entitymap.put(entity.getName(),entity.getClz()); &#125; //将mappings转换成url-pattern --&gt;servlet-name的映射存放到mappingmap中 for (Mapping mapping : mappings) &#123; for (String pattern : mapping.getPatterns()) &#123; mappingmap.put(pattern,mapping.getName()); &#125; &#125; &#125; //对外暴露一个由pattern获得servlet-class的方法 public String getClz(String pattern)&#123; //由pattern获得servletName; String servletName = mappingmap.get(pattern); //再由servletName获得servletClass; String servletClz = entitymap.get(servletName); return servletClz; &#125;&#125; 声明Servlet接口和它的子类 123public interface Servlet &#123; void service();&#125; loginServlet完成登录服务 123456public class LoginServlet implements Servlet&#123; @Override public void service() &#123; System.out.println("login service"); &#125;&#125; RegisterServlet完成注册服务 123456public class RegisterServlet implements Servlet &#123; @Override public void service() &#123; System.out.println("register service"); &#125;&#125; 具体解析代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package SAX;import org.xml.sax.Attributes;import org.xml.sax.SAXException;import org.xml.sax.helpers.DefaultHandler;import javax.xml.parsers.ParserConfigurationException;import javax.xml.parsers.SAXParser;import javax.xml.parsers.SAXParserFactory;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.util.ArrayList;import java.util.List;public class TextSAX &#123; public static void main(String[] args) throws ParserConfigurationException, SAXException, IOException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; //获得解析工厂 SAXParserFactory factory = SAXParserFactory.newInstance(); //从解析工厂获得解析器 SAXParser parser = factory.newSAXParser(); //创建处理器 WebHandler webHandler = new WebHandler(); //解析 parser.parse(Thread.currentThread().getContextClassLoader().getResourceAsStream("SAX/web.xml"),webHandler); //测试由用户传入url-pattern获得对应服务 WebContext webContext = new WebContext(webHandler.getEntities(),webHandler.getMappings()); Class clz = Class.forName(webContext.getClz("/g")); Servlet servlet =(Servlet) clz.getConstructor().newInstance(); servlet.service(); &#125;&#125;class WebHandler extends DefaultHandler &#123; private List&lt;Entity&gt; entities; private List&lt;Mapping&gt; mappings; private Entity entity; private Mapping mapping; private String currentElement; private boolean isMapping; @Override public void startDocument() throws SAXException &#123; entities = new ArrayList&lt;Entity&gt;(); mappings = new ArrayList&lt;Mapping&gt;(); &#125; @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; if(qName!=null)&#123; currentElement = qName; System.out.println("开始标签:"+currentElement); if (currentElement.equals("servlet"))&#123; entity = new Entity(); isMapping = false; &#125; if (currentElement.equals("servlet-mapping"))&#123; mapping = new Mapping(); isMapping = true; &#125; &#125; &#125; @Override public void characters(char[] ch, int start, int length) throws SAXException &#123; String content = new String(ch,start,length).trim(); if(currentElement!=null)&#123; if(isMapping)&#123; if(currentElement.equals("servlet-name"))&#123; mapping.setName(content); &#125; if (currentElement.equals("url-pattern"))&#123; mapping.addPattren(content); &#125; &#125; if(!isMapping)&#123; if(currentElement.equals("servlet-name"))&#123; entity.setName(content); &#125; if (currentElement.equals("servlet-class"))&#123; entity.setClz(content); &#125; &#125; &#125; &#125; @Override public void endElement(String uri, String localName, String qName) throws SAXException &#123; if(qName!=null)&#123; currentElement = qName; if(currentElement.equals("servlet"))&#123; entities.add(entity); &#125; if(currentElement.equals("servlet-mapping"))&#123; mappings.add(mapping); &#125; &#125; currentElement = null; &#125; public List&lt;Entity&gt; getEntities() &#123; return entities; &#125; public List&lt;Mapping&gt; getMappings() &#123; return mappings; &#125;&#125;]]></content>
      <tags>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F20%2FUML%E5%9B%BE%E5%92%8C%E6%97%B6%E5%BA%8F%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[UML图 title: UML图date: 2019-04-24 22:28:59tags: XMLtop: 99 copyright: trueUML图和时序图能很清晰地展示类与类之间的关系 车的类图结构为&lt;&gt;，表示车是一个抽象类； 它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示； 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示； 小汽车与发动机之间是组合关系，使用带实心箭头的实线表示； 学生与班级之间是聚合关系，使用带空心箭头的实线表示； 学生与身份证之间为关联关系，使用一根实线表示； 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示； 类之间的关系泛化关系(generalization)类的继承结构表现在UML中为：泛化(generalize)与实现(realize)： 继承关系为 is-a的关系；两个对象之间如果可以用 is-a 来表示，就是继承关系：（..是..) eg：自行车是车、猫是动物 泛化关系用一条带空心箭头的直接表示；如下图表示（A继承自B）； eg：汽车在现实中有实现，可用汽车定义具体的对象；汽车与SUV之间为泛化关系； 实现关系(realize)实现关系用一条带空心箭头的虚线表示； eg：”车”为一个抽象概念，在现实中并无法直接用来定义对象；只有指明具体的子类(汽车还是自行车)，才 可以用来定义对象（”车”这个类在C++中用抽象类表示，在JAVA中有接口这个概念，更容易理解） 聚合关系(aggregation)聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成； 聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成； 与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在； 组合关系(composition)组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成； 与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成； 但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了； 关联关系(association)关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系； 比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系； 关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A； 注：在最终代码中，关联对象通常是以成员变量的形式实现的； 依赖关系(dependency)依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系； 与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化； 显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生； 注：在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性；]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F19%2FJava%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[Java并发线程状态转换 使用线程三种方法 : 实现 Runnable 接口； 实现 Callable 接口； 继承 Thread 类。 实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。 实现 Runnable 接口需要实现 run() 方法。 通过 Thread 调用 start() 方法来启动线程。 12345678910public class MyRunnable implements Runnable &#123; public void run() &#123; // ... &#125;&#125;public static void main(String[] args) &#123; MyRunnable instance = new MyRunnable(); Thread thread = new Thread(instance); thread.start();&#125; 实现 Callable 接口与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。 123456789101112public class MyCallable implements Callable&lt;Integer&gt; &#123; public Integer call() &#123; return 123; &#125;&#125;public static void main(String[] args) throws ExecutionException, InterruptedException &#123; MyCallable mc = new MyCallable(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(mc); Thread thread = new Thread(ft); thread.start(); System.out.println(ft.get());&#125; 继承 Thread 类同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。 当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。 123456789public class MyThread extends Thread &#123; public void run() &#123; // ... &#125;&#125;public static void main(String[] args) &#123; MyThread mt = new MyThread(); mt.start();&#125; 大多数情况下，实现接口比继承Thread类好很多 三、基础线程机制ExecutorExecutor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。 主要有三种 Executor： CachedThreadPool：一个任务创建一个线程； FixedThreadPool：所有任务只能使用固定大小的线程； SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。 1234567public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 5; i++) &#123; executorService.execute(new MyRunnable()); &#125; executorService.shutdown();&#125; Daemon守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。 当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。 使用 setDaemon() 方法将一个线程设置为守护线程。 1234public static void main(String[] args) &#123; Thread thread = new Thread(new MyRunnable()); thread.setDaemon(true);&#125; sleep()Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。 sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。 1234567public void run() &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; yield()对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。 123public void run() &#123; Thread.yield();&#125; 四、中断一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。 InterruptedException通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。 对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。 123456789101112131415161718192021222324252627public class InterruptExample &#123; private static class MyThread1 extends Thread &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); System.out.println("Thread run"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new MyThread1(); thread1.start(); //在thread1还处于休眠时调用interupt()方法,会抛出中断异常 thread1.interrupt(); System.out.println("Main run");&#125;Main runjava.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at InterruptExample.lambda$main$0(InterruptExample.java:5) at InterruptExample$$Lambda$1/713338599.run(Unknown Source) at java.lang.Thread.run(Thread.java:745) interrupted()如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。 但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。 123456789101112131415161718public class InterruptExample &#123; private static class MyThread2 extends Thread &#123; @Override public void run() &#123; while (!interrupted()) &#123;//当线程的interrupt()方法被调用，interrupted的返回值被设为true，while循环退出，线程结束 // .. &#125; System.out.println("Thread end"); &#125; &#125;&#125;public static void main(String[] args) throws InterruptedException &#123; Thread thread2 = new MyThread2(); thread2.start(); thread2.interrupt();&#125;Thread end Executor 的中断操作调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。 以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。 12345678910111213141516171819202122public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; &#123; try &#123; Thread.sleep(2000); System.out.println("Thread run"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); //线程除于休眠时调用shutdowmNow()方法，相当于调用了interrupt()方法，抛出InterruptedException executorService.shutdownNow(); System.out.println("Main run");&#125;Main runjava.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at ExecutorInterruptExample.lambda$main$0(ExecutorInterruptExample.java:9) at ExecutorInterruptExample$$Lambda$1/1160460865.run(Unknown Source) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at java.lang.Thread.run(Thread.java:745) 如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。 1234Future&lt;?&gt; future = executorService.submit(() -&gt; &#123; // ..&#125;);future.cancel(true); 互斥同步Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。 synchronized1. 同步一个代码块 12345public void func() &#123; synchronized (this) &#123; // ... &#125;&#125; 它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。 对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。 1234567891011121314151617public class SynchronizedExample &#123; public void func1() &#123; synchronized (this) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.print(i + " "); &#125; &#125; &#125;&#125;public static void main(String[] args) &#123; SynchronizedExample e1 = new SynchronizedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; e1.func1()); executorService.execute(() -&gt; e1.func1());&#125;0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。 12345678public static void main(String[] args) &#123; SynchronizedExample e1 = new SynchronizedExample(); SynchronizedExample e2 = new SynchronizedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; e1.func1()); executorService.execute(() -&gt; e2.func1());&#125;0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 2. 同步一个方法 123public synchronized void func () &#123; // ...&#125; 它和同步代码块一样，作用于同一个对象。 3. 同步一个类 12345public void func() &#123; synchronized (SynchronizedExample.class) &#123; // ... &#125;&#125; 作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。 123456789101112131415161718public class SynchronizedExample &#123; public void func2() &#123; synchronized (SynchronizedExample.class) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.print(i + " "); &#125; &#125; &#125;&#125;public static void main(String[] args) &#123; SynchronizedExample e1 = new SynchronizedExample(); SynchronizedExample e2 = new SynchronizedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; e1.func2()); executorService.execute(() -&gt; e2.func2());&#125;0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 4. 同步一个静态方法 123public synchronized static void fun() &#123; // ...&#125; 作用于整个类。 ReentrantLockReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。 12345678910111213141516171819202122public class LockExample &#123; private Lock lock = new ReentrantLock(); public void func() &#123; lock.lock(); try &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.print(i + " "); &#125; &#125; finally &#123; lock.unlock(); // 确保释放锁，从而避免发生死锁。 &#125; &#125;&#125;public static void main(String[] args) &#123; LockExample lockExample = new LockExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; lockExample.func()); executorService.execute(() -&gt; lockExample.func());&#125;0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 比较1. 锁的实现 synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。 2. 性能 新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。 3. 等待可中断 当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。 ReentrantLock 可中断，而 synchronized 不行。 4. 公平锁 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。 synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。 5. 锁绑定多个条件 一个 ReentrantLock 可以同时绑定多个 Condition 对象。 使用选择除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。 六、线程之间的协作当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。 join()在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。 对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。 1234567891011121314151617181920212223242526272829303132333435363738394041public class JoinExample &#123; private class A extends Thread &#123; @Override public void run() &#123; System.out.println("A"); &#125; &#125; private class B extends Thread &#123; private A a; B(A a) &#123; this.a = a; &#125; @Override public void run() &#123; try &#123; a.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("B"); &#125; &#125; public void test() &#123; A a = new A(); B b = new B(a); b.start(); a.start(); &#125;&#125;public static void main(String[] args) &#123; JoinExample example = new JoinExample(); example.test();&#125;AB wait() notify() notifyAll()调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。 它们都属于 Object 的一部分，而不属于 Thread。 只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。 使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。 123456789101112131415161718192021222324public class WaitNotifyExample &#123; public synchronized void before() &#123; System.out.println("before"); notifyAll(); &#125; public synchronized void after() &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("after"); &#125;&#125;public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); WaitNotifyExample example = new WaitNotifyExample(); executorService.execute(() -&gt; example.after()); executorService.execute(() -&gt; example.before());&#125;beforeafter wait() 和 sleep() 的区别 wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法； wait() 会释放锁，sleep() 不会。 await() signal() signalAll()java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。 相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。 使用 Lock 来获取一个 Condition 对象。 1234567891011121314151617181920212223242526272829303132333435public class AwaitSignalExample &#123; private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); public void before() &#123; lock.lock(); try &#123; System.out.println("before"); condition.signalAll(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void after() &#123; lock.lock(); try &#123; condition.await(); System.out.println("after"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); AwaitSignalExample example = new AwaitSignalExample(); executorService.execute(() -&gt; example.after()); executorService.execute(() -&gt; example.before());&#125;beforeafter J.U.C - AQSjava.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心。 CountDownLatch用来控制一个线程等待多个线程。 维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。 123456789101112131415161718public class CountdownLatchExample &#123; public static void main(String[] args) throws InterruptedException &#123; final int totalThread = 10; CountDownLatch countDownLatch = new CountDownLatch(totalThread); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; totalThread; i++) &#123; executorService.execute(() -&gt; &#123; System.out.print("run.."); countDownLatch.countDown(); //一个线程执行完调用countDown()方法,计数器cnt的值减1 &#125;); &#125; countDownLatch.await(); //主线程在这里一直阻塞，直到计数器cnt的值变为0 System.out.println("end"); executorService.shutdown(); &#125;&#125;run..run..run..run..run..run..run..run..run..run..end 自己模拟实现CountDownLatch 1234567891011121314151617public class MyCountdownLatch &#123; private int cnt; //计数器 public MyCountdownLatch(int totalThread)&#123; this.cnt = totalThread; &#125; public void countDown() &#123; this.count--; &#125; public void await()&#123; while(this.cnt != 0) &#123; &#125; &#125; //...&#125; CyclicBarrier用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。 和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。 CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。 CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。 12345678910public CyclicBarrier(int parties, Runnable barrierAction) &#123; if (parties &lt;= 0) throw new IllegalArgumentException(); this.parties = parties; this.count = parties; this.barrierCommand = barrierAction;&#125;public CyclicBarrier(int parties) &#123; this(parties, null);&#125; 12345678910111213141516171819202122public class CyclicBarrierExample &#123; public static void main(String[] args) &#123; final int totalThread = 10; CyclicBarrier cyclicBarrier = new CyclicBarrier(totalThread); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; totalThread; i++) &#123; executorService.execute(() -&gt; &#123; System.out.print("before.."); try &#123; cyclicBarrier.await(); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.print("after.."); &#125;); &#125; executorService.shutdown(); &#125;&#125;//结果显示，在所有线程输出了bofore后输出afterbefore..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after.. J.U.C - 其它组件FutureTask在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。 12public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。 123456789101112131415161718192021222324252627282930313233public class FutureTaskExample &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; //用FutureTask封装一个计算任务 FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; int result = 0; for (int i = 0; i &lt; 100; i++) &#123; Thread.sleep(10); result += i; &#125; return result; &#125; &#125;); Thread computeThread = new Thread(futureTask); //future作为任务在线程中被执行 computeThread.start(); Thread otherThread = new Thread(() -&gt; &#123; System.out.println("other task is running..."); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); otherThread.start(); System.out.println(futureTask.get()); //get()方法获得任务的返回值 &#125;&#125;other task is running...4950 BlockingQueuejava.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现： FIFO 队列 ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度） 优先级队列 ：PriorityBlockingQueue 提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。 使用 BlockingQueue 实现生产者消费者问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class ProducerConsumer &#123; private static BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(5); private static class Producer extends Thread &#123; @Override public void run() &#123; try &#123; queue.put("product"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.print("produce.."); &#125; &#125; private static class Consumer extends Thread &#123; @Override public void run() &#123; try &#123; String product = queue.take(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.print("consume.."); &#125; &#125;&#125;public static void main(String[] args) &#123; for (int i = 0; i &lt; 2; i++) &#123; Producer producer = new Producer(); producer.start(); &#125; for (int i = 0; i &lt; 5; i++) &#123; Consumer consumer = new Consumer(); consumer.start(); &#125; for (int i = 0; i &lt; 3; i++) &#123; Producer producer = new Producer(); producer.start(); &#125;&#125;produce..produce..consume..consume..produce..consume..produce..consume..produce..consume.. ForkJoin主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。 12345678910111213141516171819202122232425262728293031323334353637public class ForkJoinExample extends RecursiveTask&lt;Integer&gt; &#123; private final int threshold = 5; private int first; private int last; public ForkJoinExample(int first, int last) &#123; this.first = first; this.last = last; &#125; @Override protected Integer compute() &#123; int result = 0; if (last - first &lt;= threshold) &#123; // 任务足够小则直接计算 for (int i = first; i &lt;= last; i++) &#123; result += i; &#125; &#125; else &#123; // 拆分成小任务 int middle = first + (last - first) / 2; ForkJoinExample leftTask = new ForkJoinExample(first, middle); ForkJoinExample rightTask = new ForkJoinExample(middle + 1, last); leftTask.fork(); rightTask.fork(); result = leftTask.join() + rightTask.join(); &#125; return result; &#125;&#125;public static void main(String[] args) throws ExecutionException, InterruptedException &#123; ForkJoinExample example = new ForkJoinExample(1, 10000); ForkJoinPool forkJoinPool = new ForkJoinPool(); Future result = forkJoinPool.submit(example); System.out.println(result.get());&#125; ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。 1public class ForkJoinPool extends AbstractExecutorService ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。 Java 内存模型Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。 主内存与工作内存处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。 加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。 所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。 线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。 内存间交互操作Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。 read：把一个变量的值从主内存传输到工作内存中 load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中 use：把工作内存中一个变量的值传递给执行引擎 assign：把一个从执行引擎接收到的值赋给工作内存的变量 store：把工作内存的一个变量的值传送到主内存中 write：在 store 之后执行，把 store 得到的值放入主内存的变量中 lock：作用于主内存的变量 unlock 内存模型三大特性1. 原子性Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。 有一个错误认识就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。 为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。 下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。 AtomicInteger能保证多个线程修改的原子性，使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现： 1234567891011121314151617181920212223242526public class AtomicExample &#123; private AtomicInteger cnt = new AtomicInteger(); public void add() &#123; cnt.incrementAndGet(); &#125; public int get() &#123; return cnt.get(); &#125;&#125;public static void main(String[] args) throws InterruptedException &#123; final int threadSize = 1000; AtomicExample example = new AtomicExample(); // 只修改这条语句 final CountDownLatch countDownLatch = new CountDownLatch(threadSize); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; threadSize; i++) &#123; executorService.execute(() -&gt; &#123; example.add(); countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); System.out.println(example.get());&#125; 除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。 1234567891011121314151617181920212223242526public class AtomicSynchronizedExample &#123; private int cnt = 0; public synchronized void add() &#123; cnt++; &#125; public synchronized int get() &#123; return cnt; &#125;&#125;public static void main(String[] args) throws InterruptedException &#123; final int threadSize = 1000; AtomicSynchronizedExample example = new AtomicSynchronizedExample(); final CountDownLatch countDownLatch = new CountDownLatch(threadSize); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; threadSize; i++) &#123; executorService.execute(() -&gt; &#123; example.add(); countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); System.out.println(example.get());&#125; 2. 可见性可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。 主要有三种实现可见性的方式： volatile synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。 final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。 对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。 3. 有序性有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。 也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。 先行发生原则上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。 1. 单一线程原则 Single Thread rule 在一个线程内，在程序前面的操作先行发生于后面的操作。 2. 管程锁定规则 Monitor Lock Rule 一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。 3. volatile 变量规则 Volatile Variable Rule 对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。 4. 线程启动规则 Thread Start Rule Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。 5. 线程加入规则 Thread Join Rule Thread 对象的结束先行发生于 join() 方法返回。 6. 线程中断规则 Thread Interruption Rule 对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。 7. 对象终结规则 Finalizer Rule 一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。 8. 传递性 Transitivity 如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。 十一、线程安全多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。 线程安全有以下几种实现方式： 不可变不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。 不可变的类型： final 关键字修饰的基本数据类型 String 枚举类型 Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。 对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。 12345678910public class ImmutableExample &#123; public static void main(String[] args) &#123; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); Map&lt;String, Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map); unmodifiableMap.put("a", 1); &#125;&#125;Exception in thread "main" java.lang.UnsupportedOperationException at java.util.Collections$UnmodifiableMap.put(Collections.java:1457) at ImmutableExample.main(ImmutableExample.java:9) Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。 123public V put(K key, V value) &#123; throw new UnsupportedOperationException();&#125; 互斥同步synchronized 和 ReentrantLock。 非阻塞同步互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。 互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。 1. CAS随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。 乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。 2. AtomicIntegerJ.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。 以下代码使用了 AtomicInteger 执行了自增的操作。 12345private AtomicInteger cnt = new AtomicInteger();public void add() &#123; cnt.incrementAndGet();&#125; 以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() 。 123public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1;&#125; 以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。 可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。 12345678public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; 3. ABA如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。 J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。 无同步方案要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。 1. 栈封闭多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。 123456789101112131415161718public class StackClosedExample &#123; public void add100() &#123; int cnt = 0; for (int i = 0; i &lt; 100; i++) &#123; cnt++; &#125; System.out.println(cnt); &#125;&#125;public static void main(String[] args) &#123; StackClosedExample example = new StackClosedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; example.add100()); executorService.execute(() -&gt; example.add100()); executorService.shutdown();&#125;100100 2. 线程本地存储（Thread Local Storage）如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。 符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。 可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。 对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。 12345678910111213141516171819202122public class ThreadLocalExample &#123; public static void main(String[] args) &#123; ThreadLocal threadLocal = new ThreadLocal(); Thread thread1 = new Thread(() -&gt; &#123; threadLocal.set(1); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(threadLocal.get()); threadLocal.remove(); &#125;); Thread thread2 = new Thread(() -&gt; &#123; threadLocal.set(2); threadLocal.remove(); &#125;); thread1.start(); thread2.start(); &#125;&#125;1 为了理解 ThreadLocal，先看以下代码： 12345678910111213141516public class ThreadLocalExample1 &#123; public static void main(String[] args) &#123; ThreadLocal threadLocal1 = new ThreadLocal(); ThreadLocal threadLocal2 = new ThreadLocal(); Thread thread1 = new Thread(() -&gt; &#123; threadLocal1.set(1); threadLocal2.set(1); &#125;); Thread thread2 = new Thread(() -&gt; &#123; threadLocal1.set(2); threadLocal2.set(2); &#125;); thread1.start(); thread2.start(); &#125;&#125; 它所对应的底层结构图为： 每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。 123/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null; 当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。 12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; get() 方法类似。 12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。 在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。 3. 可重入代码（Reentrant Code）这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。 可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java-I/O]]></title>
    <url>%2F2019%2F04%2F16%2FJava-IO%2F</url>
    <content type="text"><![CDATA[Java I/OJava I/O大致分类 磁盘操作：File 字节操作：InputStream 和 OutputStream 字符操作：Reader 和 Writer 对象操作：Serializable 网络操作：Socket 新的输入/输出：NIO Java IO流结构图 磁盘操作File类表示文件和目录的信息 1234567891011121314//递归地列出一个目录下所有文件public static void listAllFiles(File dir) &#123; if (dir == null || !dir.exists()) &#123; //如果dir为空或者dir不存在，直接return return; &#125; if (dir.isFile()) &#123; //如果dir时文件，输出文件名 System.out.println(dir.getName()); return; &#125; for (File file : dir.listFiles()) &#123; //如果dir是目录则对该目录下所有文件或目录进行递归操作 listAllFiles(file); &#125;&#125;//从Java7开始，可以使用Paths和Files代替File 字节操作实现文件复制 1234567891011public static void copyFile(String src,String dist) throws IOException &#123; FileInputStream in = new FileInputStream(src); FileOutputStream out = new FileOutputStream(dist); byte[] buffer = new byte[20*1024]; //buffer数组用于读取，最多读20KB int len; //len代表每次read()实际读取的字节数 while((len=in.read(buffer,0,buffer.length))!= -1)&#123; //如果read()返回-1表示读取到eof，即文件尾，退出循环 out.write(buffer,0,len); //按实际读取到的字节数len写出buffer数组的数据到dist &#125; in.close(); out.close();&#125; 装饰器模式 Java I/O 使用了装饰者模式来实现。以 InputStream 为例， InputStream 是抽象组件； FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作； FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。 实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。 12FileInputStream fileInputStream = new FileInputStream(filePath);BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream); DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。 字符操作编码与解码编码就是把字符转换为字节，而解码是把字节重新组合成字符。 如果编码和解码过程使用不同的编码方式那么就出现了乱码。 GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节； UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节； UTF-16be 编码中，中文字符和英文字符都占 2 个字节。 UTF-16be 中的 be 指的是 Big Endian，也就是大端。相应地也有 UTF-16le，le 指的是 Little Endian，也就是小端。 Java 的内存编码使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。 String 的编码方式String 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 String。 1234String str1 = "中文";byte[] bytes = str1.getBytes("UTF-8"); //将字符串str1按"UTF-8"编码编码成字节数组String str2 = new String(bytes, "UTF-8"); //将字节数组bytes按"UTF-8"编码解码成字符串System.out.println(str2); 在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。getBytes() 的默认编码方式与平台有关，一般为 UTF-8。 1byte[] bytes = str1.getBytes(); Reader 与 Writer在对磁盘非文本文件或网络传输中，都是操作字节流，但程序通常需要操作字符形式数据，这时可以用到转换流 InputStreamReader 实现从字节流解码成字符流(例如将URL类的openStream()方法获得的字节流数据转换成字符流) OutputStreamWriter 实现字符流编码成为字节流 实现逐行输出文本文件的内容123456789101112131415public static void readFileContent(String filePath) throws IOException &#123; FileReader fileReader = new FileReader(filePath); BufferedReader bufferedReader = new BufferedReader(fileReader); String line; while ((line = bufferedReader.readLine()) != null) &#123; System.out.println(line); &#125; // 装饰者模式使得 BufferedReader 组合了一个 Reader 对象 // 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法 // 因此只要一个 close() 调用即可 bufferedReader.close();&#125; 对象操作序列化序列化就是将一个对象转换成字节序列，方便存储和传输。 序列化：ObjectOutputStream.writeObject() 反序列化：ObjectInputStream.readObject() Serializable接口可被序列化的类要实现Serializable接口，该接口没有任何方法，只表示类可被序列化 123456789101112131415161718192021222324252627//代码演示序列化和可序列化public static void main(String[] args) throws IOException, ClassNotFoundException&#123; Student student = new Student("Tom",18); String objectFile = "file/a1"; ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(objectFile)); objectOutputStream.writeObject(student); //writeObject()方法写出student objectOutputStream.close(); ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(objectFile)); Student student1 = (Student)objectInputStream.readObject(); //readObject()读取对象，注意readObject返回的Object类型，在确定该对象是类型是Student情况下可以直接强转Student类对象，为了安全起见可以使用instansof运算符做一下类型检查 objectInputStream.close(); System.out.println(student1);&#125;//声明一个可被序列化的Student类private static class Student implement Serializable &#123; private String name; private String age; public Student(String name,String age)&#123; this.name = name; this.age = age; &#125; @Override public String toString()&#123; return "姓名" + name + " " + "年龄" + age; &#125;&#125; transienttransient 关键字可以使一些属性不会被序列化。 ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。 1private transient Object[] elementData; 网络操作与NIO由于涉及内容较多，有文章专门介绍 参考资料 : https://github.com/CyC2018/CS-Notes]]></content>
      <tags>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java完整学习路线]]></title>
    <url>%2F2019%2F04%2F15%2FJava%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[Java完整学习路线JavaSE(第一阶段) 技术名称 技术内容 Java基础语法 Java语法格式，常量和变量，变量的作用域，方法和方法的重载，运算符，程序流程控制，数组和操作数组的类，对数组循环遍历以及针对数组的常用查找、排序算法原理，最后使用Java程序进行功能实现。 面向对象编程 理解对象的本质，以及面向对象，类与对象之间的关系，如何用面向对象的思想分析和解决显示生活中的问题，并java程序的手段编写出来。如何设计类，设计类的基本原则，类的实例化过程，类元素：构造函数、this关键字、方法和方法的参数传递过程、static关键字、内部类，Java的垃圾对象回收机制。对象的三大特性：封装、继承和多态。子类对象的实例化过程、方法的重写和重载、final关键字、抽象类、接口、继承的优点和缺点。 对象的多态性：子类和父类之间的转换、父类纸箱子类的引用、抽象类和接口在多态中的应用、多态优点。常用设计模式如单利、模版等模式。什么是异常 异常的捕捉和抛出 异常捕捉的原则 finally的使用，package的应用 import关键字。 多线程应用 多线程的概念，如何在程序中创建多线程(Thread、Runnable)，线程安全问题，线程的同步，线程之间的通讯、死锁问题的剖析。 javaAPI详解 JavaAPI介绍、String和StringBuffer、各种基本数据类型包装类，System和Runtime类，Date和DateFomat类等。常用的集合类使用如下：Java Collections Framework：Collection、Set、List、ArrayList、Vector、LinkedList、Hashset、TreeSet、Map、HashMap、TreeMap、Iterator、Enumeration等常用集合类API。 IO技术 什么是IO，File及相关类，字节流InputStream和OutputStream，字符流Reader和Writer，以及相应缓冲流和管道流，字节和字符的转化流，包装流，以及常用包装类使用，分析java的IO性能。 网络编程 Java网络编程，网络通信底层协议TCP/UDP/IP，Socket编程。网络通信常用应用层协议简介：HTTP、FTP等，以及WEB服务器的工作原理。 java高级特性 递归程序，Java的高级特性：反射、代理和泛型、枚举、Java正则表达式API详解及其应用。 (数据库技术) 第二阶段 技术名称 技术内容 Oracle 基础管理 Oracle背景简介，数据库的安装，数据库的用户名和密码，客户端登录数据库服务SQLPLUS，数据库基本概。 SQL语句 数据库的创建，表的创建，修改，删除，查询，索引的创建，主从表的建立，数据控制授权和回收，事务控制，查询语句以及运算符的详解，sql中的函数使用。 多表连接和子查询 等值和非等值连接，外连接，自连接；交叉连接，自然连接，using子句连接，完全外连接和左右外连接，子查询使用以及注意事项。 触发器、存储过程 触发器和存储过程使用场合， 通过实例进行详解。 数据库设计优化 WHERE子句中的连接顺序，选择最有效率的表名顺序，SELECT子句中避免使用 ‘ * ‘ 计算记录条数等等。 数据备份与移植 移植技巧，备份方案；导入导出等。 JDBC技术(第三阶段) 技术名称 技术内容 JDBC基础 JDBC Connection、Statement、PreparedStatement、CallableStatement、ResultSet等不同类的使用。 连接池技术 了解连接池的概念，掌握连接池的建立、治理、关闭和配置。 ORM与DAO封装 对象关系映射思想，jdbc的dao封装，实现自己的jdbc。 Web基础技术(第四阶段) 技术名称 技术内容 Xml技术 使用jdom和dom4j来对xml文档的解析和生成操作，xml 的作用和使用场合。 html/css Java掌握基本的html标签的格式和使用，css层叠样式表对div的定义，实现对网站布局的基本实现。 Javascript 了解javascript的基本语法以及相关函数的使用，并结合html页面实现流程控制和页面效果展示。什么是异常 异常的捕捉和抛出 异常捕捉的原则 finally的使用，package的应用 import关键字。 jsp/servlet Servlet和SP 技术、上传下载、 Tomcat 服务器技术、servlet 过滤器和监听器。 jstl和EL JSTL核心标签库、函数标签库、格式化标签库、自定义标签技术、EL表达式在jsp页面的使用。 ajax及框架技术 了解和属性原生态的ajax的使用，ajax使用的场合，使用ajax的好处，ajax框架jquery渲染页面效果和相关的强大的第三方类库，dwr如何和后台服务进行数据传输，以及页面逻辑控制等。 JSON高级应用 Java使用json支持的方式对字符串进行封装和解析，实现页面和java后台服务的数据通信。 Fckeditor编辑器 FCKEditor在线编辑器技术、配置、处理图片和文件上传。 javaMail技术 了解域名解析与MX记录、电子邮件工作原理、邮件传输协议：SMTP、POP3、IMAP、邮件组织结构：RFC822邮件格式、MIME协议、邮件编码、复合邮件结构分析、JavaMail API及其体系结构、编程创建邮件内容：简单邮件内容、包含内嵌图片的复杂邮件、包含内嵌图片和附件的复杂邮件。 JfreeChart报表 统计报表；图表处理。 BBS项目实战 采用Jquery+dwr+jsp+servlet+Fckeditor+JfreeChart+tomcat+jdbc(oracle) 完成BBS项目的实战。 （web主流框架技术(项目实战)）第五阶段 技术名称 技术内容 struts2.x struts2框架的工作原理和架构分析，struts-default.xml与default.properties文件的作用，struts。Xml中引入多个配置文件。OGNL表达式、Struts2 UI和非UI标签、输入校验、使用通配符定义action、动态方法调用、多文件上传、自定义类型转换器、为Action的属性注入值、自定义拦截器、异常处理、使用struts2实现的CRUD操作的案例。 hibernate3.x Hibernate应用开发基础； ORM基础理论； 关系映射技术； 性能调优技术； 性能优化 一级缓存 二级缓存 查询缓存 事务与并发 悲观锁、乐观锁。 spring3.x Spring IoC技术； Spring AOP技术； Spring 声明事务管理； Spring 常用功能说明，spring3.0的新特性， Spring整合struts2和hibernate3的运用。 Log4j和Junit Logging API； JUnit单元测试技术； 压力测试技术：badboy 进行测试计划跟踪获取以及JMeter压力测试。 在线支付技术 完成支付宝的支付接口的在线支付功能。 电子商务网实战 采用spring3+hibernate3+struts2+jquery+dwr+FckEditor+tomcat 完成电子商务网站实战开发。 web高级进阶(项目实战)第六阶段 技术名称 技术内容 openJpa技术 JPA介绍及开发环境搭建、单表实体映射、一对多/多对一、一对一、多对多关联、实体继承、复合主键、JPQL语句、EntityManager API、事务管理，了解一下jpa2.0的新特性以及应用。 lucene搜索引擎 了解全文搜索原理、全文搜索引擎、什么是OSEM、OSEM框架Compass、基于使用Lucene使用Compass实现全文增量型索引创建和搜索、探索Lucene 3.0以及API。 电子商务网重构 此项目采用了Lucene+compass+openJpa+上一版电子商务网站的技术进行重构。 Excel/PDF文档处理技术 ava对excel和pdf文档分别利用poi和itext来进行解析和生成。此技术在企业级系统的报表中经常使用。 OA工作流技术JBPM 工作流是什么、JBPM介绍、JBPM的主要用法、各类节点的用法、任务各种分派方式、JBPM的整体架构原理、工作流定义模型分析、运行期工作流实例模型分析、数据库表模型分析、流程定义管理、流程实例监控、对JBPM的相关接口进行封装，构建自己的工作流应用平台等。 WebService技术 WebService技术原理、WebService技术的应用、Soap服务的创建与管理、WSDL描述文档规范、UDDI 注册中心运行原理;使用Axis和Xfire创建WEB服务、Webservice客户端的编写、使用TCPMonitor监听SOAP协议、异构平台的整合。 Linux技术 Linux 系统安装，卸载、linux 使用的核心思想、linux下的用户管理，文件管理,系统管理、程序的安装，使用，卸载。linux下作为server的基本应用：web服务器，j2ee服务器，ftp服务器的安装和项目的部署。 CRM项目实战 此项目能了解和熟悉客户关系管理的基本流程以及功能的实现，采用上面几个阶段学到的主流框架实现，同时加入了JBPM的技术。 大型高并发网站优化方案(项目实战)(第七阶段) 技术名称 技术内容 如何构建一个高性能网站详解 什么样的网站需要高性能，高性能的指标体系，构建高性能网站需要做哪些工作，注意哪些细节。 SSI技术 什么是SSI，使用他有什么好处，什么样的系统才使用SSI，SSI技术详解和使用，应用到项目中。 生成静态页技术 什么是静态页，为什么需要静态页以及带来的好处，生成静态页的模版技术Velocity和Freemark，生成静态页的访问规则等。 缓存技术 为什么使用缓存技术，oscache缓存技术的介绍和使用，memcached缓存技术的介绍和使用、两者缓存技术的比较和如何去使用。 经典web服务器 什么是web服务器，什么是javaweb服务器，他们存在什么关系，当前技术主流中常用的web服务器有哪些， web服务器apache和nginx的应用。 nginx架构实战 什么是反向代理，负载均衡以及集群，在nginx中如何实现这些高性能的系统架构。 清楚了完整的学习路线，你就可以正式踏上你的光头之旅啦!(滑稽~) 注明：此文章内容并非原创，转载自腾讯云]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java异常]]></title>
    <url>%2F2019%2F04%2F15%2FJava%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[Java异常如：文件找不到、网络连接失败、除0操作、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。 Java 异常的概念Java异常是一个描述在代码段中发生异常的对象，当发生异常情况时(如：文件找不到、网络连接失败、除0操作、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。)，一个代表该异常的对象被创建并且在导致该异常的方法中被抛出，而该方法可以选择自己处理异常或者传递该异常。 3. Java 异常类层次结构 异常种类 异常描述 checked exceptions(受检查的异常) 必须被try{}catch语句块所捕获，或者在方法签名里通过throws子句声明 runtime exceptions(运行时异常) 需要程序员自己分析代码决定是否捕获和处理 Error(严重错误) 需要根据业务信息进行特殊处理，Error不需要捕捉也不能捕捉 Java异常结构图解 粉红色 ：checked exceptions 蓝色 : runtime exceptions / Error 接下来更加详细地解释异常类型受查异常受查异常在编译时被检测，如果一个方法中有代码抛出受查异常，要么就地try-catch解决它， 要么就将异常throws出去，交给该方法的调用者处理，否则无法通过编译 代码演示 ： 用try - catch就地解决异常 12345678910111213141516171819202122//读取普通文本文件public static void readFile(String filePath)&#123; File file = new File(filePath); String result; BufferdReader reader = null; try&#123; reader = new BufferdReader(new FileReader(file)); while((result = reader.readLine())!=null)&#123; System.out.println(result); &#125; &#125;catch(IOException e)&#123; e.printStackTrace(); //这里也可以自定义异常信息,如System.out.println("文件读取出错"); &#125;finally&#123; //不管文件读取是否成功，最后都必须用finally执行reader.close()方法，释放系统资源 if(reader!=null)&#123; try&#123; reader.close(); &#125;catch(IOException e)&#123; System.out.println("流关闭出错"); &#125; &#125; &#125;&#125; 使用throws抛出异常 1234567891011public static void readFile(String filePath) throws IOException&#123; File file = new File(filePath); String result; BufferdReader reader = new BufferdReader(new FileReader(file)); while((result = reader.readLine())!=null)&#123; System.out.println(result); &#125; if(reader!=null)&#123; reader.close(); &#125;&#125; 非受查异常Error和RuntimeException类的子类属于非受查异常，一般无法预测，所以不会在编译时被检测 异常的处理常见三种方式(根据情况选择最适合的): 直接抛出异常 封装异常再抛出 try-catch捕获异常 直接抛出异常如果不知道如何处理异常，应该将异常抛出 封装异常在抛出有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。 12345678910public static void readFile(String filePath) throws MyException&#123; try&#123; //... &#125; catch(IOException e) &#123; MyException ex =new MyException("读取文件失败."); ex.initCause(e); throw ex; //将IOException封装成MyException再抛出 &#125;&#125; 捕获异常 在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理 1234567891011public static void readFile(String filePath)&#123; try&#123; //... &#125; catch(FileNotFoundException e) &#123; //处理 FileNotFoundException &#125; catch(IOException e)&#123; //处理 IOException &#125;&#125; 同一个 catch 也可以捕获多种类型异常，用 | 隔开 1234567891011private static void readFile(String filePath)&#123; try&#123; // ... &#125; catch(FileNotFoundException | UnknownHostException e) &#123; // 处理 FileNotFoundException 或 UnknownHostException &#125; catch(IOException e)&#123; // 处理 IOException &#125;&#125; 自定义异常自定义异常 自定义异常类最好包含一个无参构造函数和一个带有详细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用） 123456789public class MyException extends Exception&#123; //需要继承Exception类 public MyException()&#123; &#125; publicMyException(Stringmsg)&#123; super(msg); &#125; // ...&#125; try-catch-finally 当方法中发生异常，异常处之后的代码不会再执行，如果之前获取了一些本地资源需要释放，则需要在方法正常结束时和 catch 语句中都调用释放本地资源的代码，显得代码比较繁琐，finally 语句可以解决这个问题。 12345678910111213141516171819202122232425262728//以IO流读取文本文件为例public static void readFile(String filePath) throws MyException &#123; File file = newFile(filePath); String result; BufferedReader reader =null; try&#123; reader =newBufferedReader(newFileReader(file)); while((result = reader.readLine())!=null) &#123; System.out.println(result); &#125; &#125;catch(IOException e) &#123; System.out.println("readFile method catch block."); MyException ex =newMyException("read file failed."); ex.initCause(e); throw ex; //注意一点:即使 catch 中包含了 return 语句，finally 子句依然会执行。若 finally 中也包含 return 语句，finally 中的 return 会覆盖前面的 return. &#125;finally&#123; System.out.println("readFile method finally block."); if(null!= reader) &#123; try&#123; reader.close(); &#125; catch(IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; try-with-resource 上面例子中，finally 中的 close 方法也可能抛出 IOException, 从而覆盖了原始异常。JAVA 7 提供了更优雅的方式来实现资源的自动释放，自动释放的资源需要是实现了 AutoCloseable 接口的类。 123456789private static void tryWithResourceTest()&#123; /*将Scanner直接声明在try的括号中,代码块退出时，会自动调用 scanner.close 方法，和把 scanner.close 方法放在 finally 代码块中不同的是，若 scanner.close 抛出异常，则会被抑制，抛出的仍然为原始异常。被抑制的异常会由 addSusppressed 方法添加到原来的异常，如果想要获取被抑制的异常列表，可以调用 getSuppressed 方法来获取。*/ try(Scanner scanner = newScanner(newFileInputStream("c:/abc"),"UTF-8"))&#123; // ... &#125; catch(IOException e)&#123; // handle exception &#125;&#125; Java常见异常RuntimeException: 异常名 异常描述 ArrayStoreException 抛出以表示尝试将错误类型的对象存储到对象数组中。例如，以下代码生成一个ArrayStoreException ： Object x[] = new String[3]; x[0] = new Integer(0); ArithmeticException 算术异常。 例如int x = 3; int y = x/0;这样的除0操作 ClassCastException 类型转换异常，如执行Object x = new Integer(0);System.out.println((String)x); IllegalArgumentException 向方法传入非法参数异常 IndexOutOfBoundsException 索引越界异常，抛出以表示某种索引(例如数组，字符串或向量)的索引超出范围 MalformedParameterizedTypeException 当需要实例化的反射方法遇到语义畸变的参数化类型时抛出。 例如，如果参数化类型的类型参数的数量是错误的。 MissingResourceException 表示资源丢失 NullPointerException 空指针异常,以下情况抛出，1.调用一个null对象的实例方法 2.访问或修改null对象的字段 NoSuchElementException 被各种访问器方法抛出，表示被请求的元素不存在 Error： 错误名 错误描述 StackOverFlowError 堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出时抛出该错误 OutOfMemoryError 内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误 AbstractMethodError 抽象方法错误。当应用试图调用抽象方法时抛出 AssertionError 用来指示一个断言失败的情况 ClassCircularityError 类循环依赖错误。在初始化一个类时，若检测到类之间循环依赖则抛出该异常 ClassFormatError 类格式错误。当Java虚拟机试图从一个文件中读取Java类，而检测到该文件的内容不符合类的有效格式时抛出。 ExceptionInInitializerError 初始化程序错误。当执行一个类的静态初始化程序的过程中，发生了异常时抛出。静态初始化程序是指直接包含于类中的static语句段。 IllegalAccessError 违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。 IncompatibleClassChangeError 不兼容的类变化错误。当正在执行的方法所依赖的类定义发生了不兼容的改变时，抛出该异常。一般在修改了应用中的某些类的声明定义而没有对整个应用重新编译而直接运行的情况下，容易引发该错误。 错误名 错误描述 InstantiationError 实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常. InternalError 内部错误。用于指示Java虚拟机发生了内部错误。 LinkageError 链接错误。该错误及其所有子类指示某个类依赖于另外一些类，在该类编译之后，被依赖的类改变了其类定义而没有重新编译所有的类，进而引发错误的情况。 NoSuchFieldError 当应用试图访问或者修改某类的某个域，而该类的定义中没有该域的定义时抛出该错误。 NoSuchMethodError 方法不存在错误。当应用试图调用某类的某个方法，而该类的定义中没有该方法的定义时抛出该错误。 UnknownError 未知错误。用于指示Java虚拟机发生了未知严重错误的情况。 UnsatisfiedLinkError 未满足的链接错误。当Java虚拟机未找到某个类的声明为native方法的本机语言定义时抛出。 NoClassDefFoundError 未找到类定义错误。当Java虚拟机或者类装载器试图实例化某个类，而找不到该类的定义时抛出该错误。 VirtualMachineError 虚拟机错误。用于指示虚拟机被破坏或者继续执行操作所需的资源不足的情况。 Java异常常见面试题Error 和 Exception 区别是什么？ Error 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，JAVA 应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复； Exception 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。 运行时异常和一般异常区别是什么？ 编译器不会对运行时异常进行检测，没有 try-catch，方法签名中也没有 throws 关键字声明，编译依然可以通过。如果出现了 RuntimeException, 那一定是程序员的错误。 一般异常如果没有 try-catch，且方法签名中也没有用 throws 关键字声明可能抛出的异常，则编译无法通过。这类异常通常为应用环境中的错误，即外部错误，非应用程序本身错误，如文件找不到等。 NoClassDefFoundError 和 ClassNotFoundException 区别是什么？ NoClassDefFoundError 是一个 Error 类型的异常，是由 JVM 引起的，不应该尝试捕获这个异常。引起该异常的原因是 JVM 或 ClassLoader 尝试加载某类时在内存中找不到该类的定义，该动作发生在运行期间，即编译时该类存在，但是在运行时却找不到了，可能是变异后被删除了等原因导致； ClassNotFoundException 是一个受查异常，需要显式地使用 try-catch 对其进行捕获和处理，或在方法签名中用 throws 关键字进行声明。当使用 Class.forName, ClassLoader.loadClass 或 ClassLoader.findSystemClass 动态加载类到内存的时候，通过传入的类路径参数没有找到该类，就会抛出该异常；另一种抛出该异常的可能原因是某个类已经由一个类加载器加载至内存中，另一个加载器又尝试去加载它。 JVM 是如何处理异常的？ 在一个方法中如果发生异常，这个方法会创建一个一场对象，并转交给 JVM，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。 JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。 throw 和 throws 的区别是什么？ throw 关键字用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。 throws 关键字用在方法签名处，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。 常见的 RuntimeException 有哪些？ ClassCastException(类转换异常) IndexOutOfBoundsException(数组越界) NullPointerException(空指针) ArrayStoreException(数据存储异常，操作数组时类型不一致) 还有IO操作的BufferOverflowException异常 参考资料 : https://github.com/CyC2018/CS-Notes ​ https://www.cnblogs.com/cvst/p/5822373.html]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java容器]]></title>
    <url>%2F2019%2F04%2F13%2FJava%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[本文章借鉴于GitHub，本人只是根据自身学习情况做了一些删改，并添加了一些自己的理解原文链接 : https://github.com/CyC2018/CS-Notes Java容器1.概览Java容器只要包括collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。 Collection框架图 Collection种类 特点 TreeSet 基于红黑树实现，支持有序性操作，可以根据一个范围查找元素。查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 HashSet 基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。 LinkedHashSet 具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。 ArrayList(常用) 基于动态数组实现，支持随机访问，线程不安全 Vector 和 ArrayList 类似，但它是线程安全的 LinkedList 基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列 LinkedList： 可以用它来实现双向队列 PriorityQueue： 基于堆结构实现，可以用它来实现优先队列 Map框架图 Map种类 特点 TreeMap 基于红黑树实现 HashMap 基于哈希表实现 LinkedHashMap 使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序 HashTable 不支持使用，可以用ConcurrentHashMap替代 容器中的设计模式迭代器模式 Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。 从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。 123456List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add("a");list.add("b");for (String item : list) &#123; //增强for循环就是通过Collection的Iterator对象遍历元素 System.out.println(item);&#125; 适配器模式java.util.Arrays#asList() 可以把数组类型转换为 List 类型。 12@SafeVarargspublic static &lt;T&gt; List&lt;T&gt; asList(T... a) 应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。 12Integer[] arr = &#123;1, 2, 3&#125;;List list = Arrays.asList(arr); 也可以使用以下方式调用 asList()： 1List list = Arrays.asList(1, 2, 3); //自动装箱 源码分析ArrayList概览 实现了RandomAccess接口，支持快速存取访问 实现了Cloneable接口，支持克隆 实现了java.io.Serializable，支持序列化与反序列化 12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 基本属性12private transient Object[] elementData; //ArrayList底层由Obiect数组实现private int size; //elementData中实际存放元素的个数 构造器1234567891011public ArrayList(int initialCapacity) &#123; //传入指定容量 super(); //调用父类构造器 if (initialCapacity &lt; 0) //如果指定容量小于0，抛出参数不合法异常 throw new IllegalArgumentException(); this.elementData = new Object[initialCapacity]; &#125; //如果未指定容量则默认容量为10 public ArrayList() &#123; this(10); //调用ArrayList(int initialCapacity)&#123;&#125;构造器 &#125; modCountmodCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。 在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。 扩容12345678910111213141516171819202122232425private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //新容量为旧容量的1.5倍 if (newCapacity - minCapacity &lt; 0) //如果新容量仍然小于指定容量 newCapacity = minCapacity; //新容量等于指定容量 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 删除元素调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，ArrayList 删除元素的代价很高。 12345678910public E remove(int index) &#123; rangeCheck(index); //检查指定下标是否合理 modCount++; E oldValue = elementData(index); //获得要删除的元素 int numMoved = size - index - 1; //计算应移动的元素个数 if (numMoved &gt; 0) //如果需要移动的元素个数大于0,进行移动操作 System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // 将数组最后一个元素设为null return oldValue; //返回被删除的元素&#125; 序列化ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。 123456789101112131415161718private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; //记录操作前的modCount值 s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); //写出数组大小 //按正确顺序写出所有元素 for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; //如果序列化后modCount的值发生了改变，抛出异常 throw new ConcurrentModificationException(); &#125;&#125; 反序列化123456789101112131415161718192021private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // 读取大小和任何 s.defaultReadObject(); // 读入容量 s.readInt(); // 忽略 if (size &gt; 0) &#123; //类似clone()，根据大小而不是容量分配数组 ensureCapacityInternal(size); Object[] a = elementData; // 按指定顺序写入所有元素 for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125;&#125; Vector同步它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。 12345678910111213public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;&#125;public synchronized E get(int index) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); return elementData(index);&#125; 与 ArrayList 的比较 Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制； Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。 替代方案可以使用 Collections.synchronizedList(); 得到一个线程安全的 ArrayList。 12List&lt;String&gt; list = new ArrayList&lt;&gt;();List&lt;String&gt; synList = Collections.synchronizedList(list); //需要传入普通List对象 也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。 1List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); CopyOnWriteArrayList读写分离写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。 写操作需要加锁，防止并发写入时导致写入数据丢失。 写操作结束之后需要把原始数组指向新的复制数组。 123456789101112131415161718public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); //写操作之前加锁 try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); //复制数组 newElements[len] = e; //将e添加到复制数组的末尾 setArray(newElements); //将原始数组指向新的复制数组 return true; &#125; finally &#123; lock.unlock(); //不管写操作是否成功,最后都释放锁 &#125;&#125;final void setArray(Object[] a) &#123; array = a;&#125; 1234@SuppressWarnings("unchecked")private E get(Object[] a, int index) &#123; return (E) a[index];&#125; 适用场景优点：CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。 缺陷： 内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右； 数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。 所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景 LinkedList概览基于双向链表实现，使用 Node 存储链表节点信息。 12345private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev;&#125; 每个链表存储了 first 和 last 指针： 12transient Node&lt;E&gt; first;transient Node&lt;E&gt; last; 与 ArrayList 的比较 ArrayList 基于动态数组实现，LinkedList 基于双向链表实现； ArrayList 支持随机访问，LinkedList 不支持； LinkedList 在任意位置添加删除元素更快。 HashMap常用API 方法名 描述 final int hash(Object k) 由Key的hashCode计算hash public V put(Object key, Object value) 向HashMap中添加键值对 public V get(Object key) 由指定的key得到键值对 public boolean containsKey(Object key) 判断HashMap中是否包含键值对key public V remove(Object key) 移除键值对 public void clear() 清空HashMap … 存储结构内部包含了一个 Entry 类型(键值对)的数组 table。 1transient Entry[] table; Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值相同的 Entry。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; //key只能读取,不能更改,设置为常量 V value; Entry&lt;K,V&gt; next; //指向下一个键值对 int hash; //构造方法 Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; //注意:这里将当前键值对指向传入的键值对 key = k; hash = h; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; //重写equals()方法 public final boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) //如果o不是Map.Entry类型的实例，直接返回false return false; Map.Entry e = (Map.Entry)o; //将o强转为Map.Entry类型 //分别获得当前对象与待比较对象的key Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123; //如果两对象的key为'=='或者等价,再分别获得两对象的value Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) //如果两对象的value为'=='或者等价,返回true return true; &#125; return false; &#125; //重写hashCode() public final int hashCode() &#123; return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue()); &#125; //重写toString public final String toString() &#123; return getKey() + "=" + getValue(); &#125;&#125; PS : 从 JDK 1.8 开始，一个桶存储的链表长度大于 8 时会将链表转换为红黑树 2. 拉链法的工作原理1234HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();map.put("K1", "V1");map.put("K2", "V2");map.put("K3", "V3"); 新建一个 HashMap，默认大小为 16； 插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。 插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。 插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 &lt;K2,V2&gt; 前面。 (注意:K3虽然与K2的hashCode和桶下表相同，但他们的value不同，而根据HashMap的equals()方法，两个等价键值对必须key和value同时等价，所以K2与K3是不同的，这意味着K3能在K2已经存在的情况下顺利地插入桶下标为6的链表中) –-应该注意到链表的插入是以头插法方式进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在链表头部。 查找需要分成两步进行： 计算键值对所在的桶； 在链表上顺序查找，时间复杂度显然和链表的长度成正比。 计算 hash 值1234567891011121314151617final int hash(Object k) &#123; int h = hashSeed; if (0 != h &amp;&amp; k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h ^= k.hashCode(); This function ensures that hashCodes that differ only by constant multiples at each bit position have a bounded number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125;public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value);&#125; 确定桶下标很多操作都需要先确定一个键值对所在的桶下标。 12int hash = hash(key);int i = indexFor(hash, table.length); put 操作(插入键值对)1234567891011121314151617181920212223242526public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; // 键为 null 单独处理 if (key == null) return putForNullKey(value); int hash = hash(key); //通过hash方法对key的hashCode（）进行二次加工。减少碰撞 // 确定桶下标 int i = indexFor(hash, table.length); // 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; //for循环顺序便利桶下表为i的链表 Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); //记录一下 return oldValue; &#125; &#125; modCount++; //modcount与线程安全有关，在使用迭代器遍历HashMap时，一旦modCount发生变化就抛出异常 // 如果没有找到,插入新键值对 addEntry(hash, key, value, i); return null;&#125; HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。 1234567891011121314private V putForNullKey(V value) &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) &#123; //如果找到key为null的键值对,直接更新该键值对 V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(0, null, value, 0); return null;&#125; 使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。 1234567891011121314151617void addEntry(int hash, K key, V value, int bucketIndex) &#123; //如果HashMap的元素个数超过了最大容量并且桶下表不为null if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); //扩容 hash = (null != key) ? hash(key) : 0; //得到hash值 bucketIndex = indexFor(hash, table.length); //得到桶下标 &#125; createEntry(hash, key, value, bucketIndex); //调用插入键值对方法&#125;void createEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; // 头插法，链表头部指向新的键值对 table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); //调用Entry的构造方法,构造方法中的next = n 使 table[bucketIndex]自动指向e size++;&#125; PS : 构造方法 //构造方法 Entry(int h, K k, V v, Entry&lt;K,V&gt; n) { value = v; next = n; //注意:这里将当前键值对指向传入的键值对 key = k; hash = h; } get操作(通过key获得键值对)12345678910111213public V get(Object key)&#123; if(k == null) return getForNullKey(); int hash = hash(key)； //计算hash值 int i = indexFor(hash, table.length); //得到桶下标 for(Entry&lt;K,V&gt; e = table[i]; e != null;e = e.next)&#123; Object k; if(e.hash == hash &amp;&amp; ((k = e.key) == key || k.equals(key)))&#123; return e.value; &#125; &#125; return null;&#125; clear()1234567public void clear() &#123; modCount++; Entry[] tab = table; for (int i = 0; i &lt; tab.length; i++) tab[i] = null; //直接将每个table置为null，等待GC释放空间 size = 0;&#125; HashMap的其他方法实现方式都类似，就不再一一列举了。 HashMap与 HashTable 的比较 HashTable 使用 synchronized 来进行同步。 HashMap 可以插入键为 null 的 Entry。 HashMap 的迭代器是 fail-fast 迭代器。 HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。 ConcurrentHashMap存储结构123456static final class HashEntry&lt;K,V&gt; &#123; final int hash; final K key; volatile V value; volatile HashEntry&lt;K,V&gt; next;&#125; ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数(Segment 继承自 ReentrantLock)）。 默认的并发级别为 16，也就是说默认创建 16 个 Segment。 1static final int DEFAULT_CONCURRENCY_LEVEL = 16; size 操作每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。 1transient int count; 在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。 ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。 尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。 如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。 3. JDK 1.8 的改动JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。 JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。 并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。 LinkedHashMap存储结构继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。 1public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt; 内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。 1234//双向链表的头节点transient LinkedHashMap.Entry&lt;K,V&gt; head;//双向链表的尾节点transient LinkedHashMap.Entry&lt;K,V&gt; tail; accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。 1final boolean accessOrder; LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。 12void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;void afterNodeInsertion(boolean evict) &#123; &#125; afterNodeAccess()当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。 afterNodeInsertion()在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。 evict 只有在构建 Map 的时候才为 false，在这里为 true。 1234567void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest LinkedHashMap.Entry&lt;K,V&gt; first; if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123; K key = first.key; removeNode(hash(key), key, null, false, true); &#125;&#125; removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。 123protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123; return false;&#125; LRU 缓存以下是使用 LinkedHashMap 实现的一个 LRU 缓存： 设定最大缓存空间 MAX_ENTRIES 为 3； 使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序； 覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。 123456789101112131415161718192021class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123; private static final int MAX_ENTRIES = 3; protected boolean removeEldestEntry(Map.Entry eldest) &#123; return size() &gt; MAX_ENTRIES; &#125; LRUCache() &#123; super(MAX_ENTRIES, 0.75f, true); &#125;&#125;public static void main(String[] args) &#123; LRUCache&lt;Integer, String&gt; cache = new LRUCache&lt;&gt;(); cache.put(1, "a"); cache.put(2, "b"); cache.put(3, "c"); cache.get(1); cache.put(4, "d"); System.out.println(cache.keySet());&#125;[3, 1, 4] WeakHashMap存储结构WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。 WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。 1private static class Entry&lt;K,V&gt; extends WeakReference&lt;Object&gt; implements Map.Entry&lt;K,V&gt; ConcurrentCacheTomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。 ConcurrentCache 采取的是分代缓存： 经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）； 不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。 当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。 当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。 1234567891011121314151617181920212223242526272829303132public final class ConcurrentCache&lt;K, V&gt; &#123; private final int size; private final Map&lt;K, V&gt; eden; private final Map&lt;K, V&gt; longterm; public ConcurrentCache(int size) &#123; this.size = size; this.eden = new ConcurrentHashMap&lt;&gt;(size); this.longterm = new WeakHashMap&lt;&gt;(size); &#125; public V get(K k) &#123; V v = this.eden.get(k); if (v == null) &#123; v = this.longterm.get(k); if (v != null) this.eden.put(k, v); &#125; return v; &#125; public void put(K k, V v) &#123; if (this.eden.size() &gt;= size) &#123; this.longterm.putAll(this.eden); this.eden.clear(); &#125; this.eden.put(k, v); &#125;&#125; 参考资料 : https://github.com/CyC2018/CS-Notes]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaObject类详解]]></title>
    <url>%2F2019%2F04%2F13%2FJavaObject%E7%B1%BB%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Object类方法概览123456789101112131415161718192021public native int hashCode() //返回对象的散列值public boolean equals(Object obj) //判断两对象是否等价protected native Object clone() throws CloneNotSupportedExceptionpublic String toString() //返回对象字符串形式public final native Class&lt;?&gt; getClass() //获得类型的class对象protected void finalize() throws Throwable &#123;&#125;public final native void notify()public final native void notifyAll()public final native void wait(long timeout) throws InterruptedExceptionpublic final void wait(long timeout, int nanos) throws InterruptedExceptionpublic final void wait() throws InterruptedException equals()方法1.实现 检查是否为同一个对象的引用，如果是直接返回 true； 检查是否是同一个类型，如果不是，直接返回 false； 将 Object 对象进行转型； 判断每个关键域是否相等。 12345678910111213141516171819202122232425public class EqualExample &#123; private int x; private int y; private int z; public EqualExample(int x, int y, int z) &#123; this.x = x; this.y = y; this.z = z; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; //如果是同一对象的引用,返回ture if (o == null || getClass() != o.getClass()) return false; //如果o为null或者this对象的类型与o的类型不同,返回false EqualExample that = (EqualExample) o; //将o转型为EqualExample //对每个关键域进行比较 if (x != that.x) return false; if (y != that.y) return false; return z == that.z; &#125;&#125; 2.equals()与 “==” 运算符的区别表格表示 : 基本类型 引用类型 equals()方法 没有equals()方法 判断引用的类型是否等价 “==”运算符 判断两值是否相等 判断两个变量是否引用同一对象 代码示例 : 1234Integer x = new Integer(1);Integer y = new Integer(1);System.out.println(x.equals(y)); // x与y所引用的对象等价,返回trueSystem.out.println(x == y); // x与y引用的是不同对象,返回false 3.hashCode()hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。 4.toString()返回对象的字符串形式，一般需要在子类中重写 默认返回 ClassName@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。 参考资料 : https://github.com/CyC2018/CS-Notes]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承与多态]]></title>
    <url>%2F2019%2F04%2F13%2F%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[Java继承与多态1.继承java只支持单继承 2.super关键字super 关键字的功能： 与this不同，this表示当前对象，super表示父类对象 调用父类中声明为 private 的变量。 调用已经覆盖了的方法。 作为方法名表示父类构造方法。 调用隐藏变量和被覆盖的方法12345678910111213141516171819202122232425262728class People&#123; private String str = "学无止境"; public String getStr() &#123; return str; &#125; public void learn()&#123; System.out.println("人可以靠学习充实自己"); &#125;&#125;class Student extends People&#123; @OverRide public void learn()&#123; super.learn(); // 调用父类的方法 // 通过 getter 方法调用父类隐藏变量 System.out.println("Please remember: " + super.getDesc()); &#125;&#125;public class Demo&#123; public static void main(String[] args) &#123; Student student = new Student(); student.learn(); &#125;&#125;/*运行结果：人可以靠学习充实自己Please remember:学无止境*/ learn() 方法也可以定义在某些祖先类中，Java 具有追溯性，会一直向上找，直到找到该方法为止。 通过 super 调用父类的隐藏变量，必须要在父类中声明 getter 方法，因为声明为 private 的数据成员对子类是不可见的。 重写与重载1. 重写（Override） 存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。 下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中： 重写使用 @Override 注解 子类方法访问权限为 public，大于父类的 protected。 子类的返回类型为 ArrayList，是父类返回类型 List 的子类。 子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。 123456789101112class SuperClass &#123; protected List&lt;Integer&gt; func() throws Throwable &#123; return new ArrayList&lt;&gt;(); &#125;&#125;class SubClass extends SuperClass &#123; @Override public ArrayList&lt;Integer&gt; func() throws Exception &#123; return new ArrayList&lt;&gt;(); &#125;&#125; 2. 重载（Overload） 存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。 需要特别注意的是，返回值不同，其它都相同不算是重载。 2.多态多态的定义多态是指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用） 实现多态的技术实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法 多态的作用消除类型之间的耦合关系 多态存在的必要条件 要有继承 要有重写 父类引用指向子类对象 Java中多态的实现方式实现接口，继承父类方法进行重写，同一个类中进行方法重载 instanceof 运算符作用：java 中的instanceof运算符通过返回一个布尔值来指出，这个对象是否是这个特定类或者是它的子类的一个实例 该运算符语法: Object object.intanceof(Class classname/Interface interfacename),返回值有以下结果: 如果对象object是类Classname或者其子类的实例,返回true; 如果对象object实现了interfacename,返回true; 其他情况返回false 一个简单的例子 12345678910111213141516171819202122232425262728293031323334353637interface Learn&#123; void learn();&#125;class People implements Learn&#123; @Override public void learn()&#123; System.out.println("一个人在学习..."); &#125;&#125;class Student extends People&#123; @Override public void learn()&#123; System.out.println("一个学生在学习..."); &#125;&#125;class Teacher extends People&#123;&#125;public class Text&#123; public static void main(String[] args)&#123; People people = new Student(); //定义一个实际类型为Student的引用people if(people instanceof Object) &#123; System.out.println("people是一个对象");&#125; //true，people是Object的 if(people instanceof People) &#123; System.out.println("people是一个人");&#125; //true,people是People的子类 if(people instanceof Student) &#123;System.out.println("people是一个学生");&#125; //true,people本身是Student类的对象 if(people instanceof Teacher) &#123;System.out.println("people是一个教室");&#125; //false,people与Teather都是People的子类,属于平行关系 if(people instanceof Learn) &#123;System.out.println("people可以学习")&#125; &#125;&#125;//运行结果people是一个对象people是一个人people是一个学生people可以学习 多态对象的类型转换假设有以下继承关系 12345678910111213141516171819class Animal&#123; public void shout()&#123; System.out.println("A animal is shouting..."); &#125;&#125;class Dog extends Animal&#123; @Override public void shout() &#123; System.out.println("wang!"); &#125;&#125;class Cat extends Animal&#123; @Override public void shout() &#123; System.out.println("miao!"); &#125;&#125; 1.安全的向上转型继承链下级类型的向上级转型，不存在风险，多态的一种体现 123456public static void main(String[] args)&#123; Dog dog = new Dog(); Animal animal = dog; //发生了隐式的向上转型 //向上转型会损失一些数据与方法，例如animal将无法访问Dog类的新增方法，只能访问 Dog类中从Animal类中继承来的方法&#125; 不安全的强制转型继承链上次的类型向下级转型，存在风险 1234public static void main(String[] args)&#123; Animal animal = new Dog(); Cat cat = (Cat)animal; //这里能顺利通过编译,因为编译器会将animal看作Animala类型的引用,但在运行期,animal的实际类型被确定为Dog,将Dog类型强行转换为Cat类型会报错&#125; 使用instanceof进行安全的强制类型转换123456789101112131415161718192021222324252627public class Demo &#123; public static void main(String[] args) &#123; Animal animal = new Dog(); //代码1 animal.shout(); //根据多态,Animal类型引用animal可以调用Dog类对象的shout()方法 /* 但有一点值得注意，由于多态的动态绑定，animal的实际类型是在运行时才确定的， 也就是说，当我们无法看见代码1时,我们就无法事先知道animal到底指向的是 Dog对象还是Cat对象,此时若贸然执行animal.shout(),执行的结果必定也是未知的(很 简单，如果animal实际对象类型是Dog，则输出"wang!",如果是Cat,则执行"miao!",但 我们并不知道实际对象类型) */ /*为了解决上述情况，我们可以在执行animal.shout()语句前，先用instanceof运算符 判断出animal的类型，再根据相应的类型执行相应的动作*/ if(animal instanceof Dog)&#123; //如果animal是Dog类的实例 Dog dog = (Dog)animal; //将animal强制转型为Dog类型 dog1.shout(); &#125; if(animal instanceof Cat)&#123; //如果animal是Cat类的实例 Cat cat = (Cat)amimal; //将animal强制转型为Cat类型 cat.shout(); &#125; &#125;&#125;/*执行结果wang!wang!*/]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础语法与数据类型]]></title>
    <url>%2F2019%2F04%2F12%2FJava%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一、基本类型 byte/8 char/16 short/16 int/32 float/32 long/64 boolean/ 包装类型基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。 12Integer x = 2; // 装箱int y = x; // 拆箱 缓存池new Integer(123) 与 Integer.valueOf(123) 的区别在于： new Integer(123) 每次都会新建一个对象； Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。 123456Integer x = new Integer(123); Integer y = new Integer(123);System.out.println(x == y); // false,x与y为不同对象的引用Integer z = Integer.valueOf(123);Integer k = Integer.valueOf(123);System.out.println(z == k); // true,x与y为缓冲池中同一对象的引用 valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) //判断i是否在-128~127之间 return IntegerCache.cache[i + (-IntegerCache.low)]; //为true返回缓冲池中对象 return new Integer(i); //为false返回一个新对象&#125; 在 Java 8 中，Integer 缓存池的大小默认为 -128~127。 编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。 123Integer m = 123;Integer n = 123;System.out.println(m == n); // true 基本类型对应的缓冲池如下： boolean values true and false all byte values short values between -128 and 127 int values between -128 and 127 char in the range \u0000 to \u007F 在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。 二、StringString在java中表示不可变字符串。 1234567public final class String //String不可继承 implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; private final byte[] value; //value初始化之后不能再引用其他数组,保证String数据不可变 private final byte coder; //指定编码&#125; value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。 String Pool字符串常量池(String Pool)保存所有字符串的字面量，这些字面量在编译时确定。 intern()方法当一个String对象调用intern()方法时,如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。 1234567String s1 = new String("aaa");String s2 = new String("aaa");System.out.println("s1 == s2"); false,s1,s2引用堆中不同对象 String s3 = s1.intern(); StringPool中先添加字符串"aaa",然后s3引用该字符串String s4 = s1.intern(); StringPool已经存在字符串"aaa",s4直接引用该字符串System.out.println(s3==s4); true,s3,s4引用的是StringPool中同一个字符串"aaa" 字面量形式创建字符串如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中，区别于使用new在堆中创建对象 123String s5 = "bbb"; StringPool新增字符串"bbb"String s6 = "bbb"; 引用StringPool中的"bbb"System.out.println(s5 == s6); // true new String(“abc”)如果StringPool中没有“abc”，这种方式会创建两个字符串对象: “abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象 “abc” 堆中创建一个字符串对象“abc”。 String构造函数源码以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。 1234public String(String original) &#123; this.value = original.value; this.hash = original.hash;&#125; String，StringBuffer，StringBuilder1. 可变性 String 不可变 StringBuffer 和 StringBuilder 可变 2. 线程安全 String 不可变，因此是线程安全的 StringBuilder 线程不安全 StringBuffer 是线程安全的，内部使用 synchronized 进行同步 三、运算隐式类型转换隐式类型转换指的是低精度数据类型转换为转换为高精度数据类型, 不会损失精度，如short(16)–&gt; int(32)，int (32)–&gt; double(64)，数据类型的精度可以理解为在内存中占的字节长度。 byte/8 char/16 short/16 int/32 float/32 long/64 boolean/ 强制类型转换(向下转型)强制类型转换指的是将高精度数据类型强制转换为低精度数据类型，会损失精度，如int(32)–&gt;short(16)，double(64)–&gt;int(32） 一个例子 12double value = 3.1416926;int value1 = (int) value; //double类型强制转换为int型 可想而知，由于double类型为64位，而int类型为32位，用一个int类型变量去接收double类型变量，只能接收到低32位，而高32位的数据便丢失了，也就是损失了精度 switch语句从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。 123456789String s = "a";switch (s) &#123; case "a": System.out.println("aaa"); break; case "b": System.out.println("bbb"); break;&#125; 四、关键字final1.final修饰数据声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。 对于基本类型，final 使数值不变； 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。 1234final int value = 1; value的值将不能修改final Student stu = new Student(); stu将不能引用其他Student对象stu.name="傻狍子"; stu本身数据可以修改 2. final修饰方法 声明方法不能被子类重写。 1public final viod Method()&#123;&#125; //Method方法不能被重写 private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。 3. final修饰类 声明类不允许被继承。 1public final class String&#123;&#125; //String类不可被继承 static1. 静态变量 静态变量：直接属于类，在类初始化时被初始化，通过类名直接访问 实例变量：属于实例，与实例一起初始化与销毁 1234567891011public class Student &#123; private int age; // 实例变量 private static int studentNumber; // 静态变量 public static void main(String[] args) &#123; Student student = new Student(); int age = student.getAge(); int number = Student.studentNumber; //类名直接访问 &#125; ...&#125; 2. 静态方法 静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。 只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。 123456public class Student &#123; private static int studentNumber; public static int getStudentNummber()&#123; //返回学生总数 return studentNumber; &#125;&#125; 3. 静态语句块 静态语句块只在类初始化时运行一次。 123456public class Student &#123; static &#123; System.out.println("加载学生类"); &#125; &#125; 4. 静态内部类 非静态内部类依赖于外部类的实例，而静态内部类不需要。 12345678910111213141516public class OuterClass &#123; class InnerClass &#123; &#125; static class StaticInnerClass &#123; &#125; public static void main(String[] args) &#123; OuterClass outerClass = new OuterClass(); //使用外部类对象.new 静态内部类()的语法来创建静态内部类对象 InnerClass innerClass = outerClass.new InnerClass(); //静态内部类可以直接创建 StaticInnerClass staticInnerClass = new StaticInnerClass(); &#125;&#125; 静态内部类不能访问外部类的非静态的变量和方法。 5. 静态导包 在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。 1import static com.xxx.ClassName 6. 初始化顺序 静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。 12345678public static String staticField = "静态变量"; //最先执行static &#123; System.out.println("静态语句块"); //其次&#125;public String field = "实例变量"; //其次&#123; System.out.println("普通语句块"); //其次&#125; 最后才是构造函数的初始化。 123public InitialOrderTest() &#123; System.out.println("构造函数"); //最后执行&#125; 存在继承的情况下，初始化顺序为： 父类（静态变量、静态语句块） 子类（静态变量、静态语句块） 父类（实例变量、普通语句块） 父类（构造函数） 子类（实例变量、普通语句块） 子类（构造函数） 五、 面向对象基本特性1.继承java只支持单继承 2.super关键字super 关键字的功能： 与this不同，this表示当前对象，super表示父类对象 调用父类中声明为 private 的变量。 调用已经覆盖了的方法。 作为方法名表示父类构造方法。 调用隐藏变量和被覆盖的方法1234567891011121314151617181920212223242526272829class People&#123; private String str = "学无止境"; public String getStr() &#123; return str; &#125; public void learn()&#123; System.out.println("人可以靠学习充实自己"); &#125;&#125;class Student extends People&#123; @OverRide public void learn()&#123; super.learn(); // 调用父类的方法 // 通过 getter 方法调用父类隐藏变量 System.out.println("Please remember: " + super.getDesc()); &#125;&#125;public class Demo&#123; public static void main(String[] args) &#123; Student student = new Student(); student.learn(); &#125;&#125;/*运行结果：人可以靠学习充实自己Please remember:学无止境*/ learn() 方法也可以定义在某些祖先类中，Java 具有追溯性，会一直向上找，直到找到该方法为止。 通过 super 调用父类的隐藏变量，必须要在父类中声明 getter 方法，因为声明为 private 的数据成员对子类是不可见的。 参考资料 : https://github.com/CyC2018/CS-Notes]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[博客的起点]]></title>
    <url>%2F2019%2F04%2F12%2F%E5%8D%9A%E5%AE%A2%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[## 博客用途 : 作为编程学习笔记,让知识系统化,方便学习中查看 正式学习需了解 : Java 完整学习路线 JAVA 基础 JAVA 概述 JAVA 基础语法与数据类型 JAVA 继承与多态 JAVA Object类详解 JAVA 容器 JAVA 异常 JAVA I/O 一些小练习 SAX解析XML 由于博客只搭建了几天，更多文章以后会陆续更新。。。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Typora基本用法]]></title>
    <url>%2F2019%2F04%2F12%2FTypora%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Typora编辑器 —-书写即为美学官方网站:https://www.typora.io/ 支持平台 Windows Linux OSX 特点: 完美支持GitHub的Markdown语法; 人性化的书写方式: 表格的书写、挪动; 图片、超链接、网页表格复制; 目录生成; 支持LeTex公式书写; 支持Flowchart,Mermaid等流程图绘制; emoji,高亮,备注,上标,下标等书写; 生成网页,pdf,图片,甚至word,LeTex等格式。 基本的带快捷键的Markdown书写演示Ctrl+0到Ctrl4:普通文本、一级~四级标题; Ctrl+B : 加粗,加粗测试; Ctrl+I : 斜体,斜体测试; Ctrl+U: 下划线,下划线测试； Shift Alt+5: 删除线,删除线测试； 单机一下 ` : 行内代码块; Ctrl+K : 超链接,超链接测试;还支持文章内锚点,请Ctrl点击此处–&gt;第二节； Ctrl+T : 表格,支持拖拽移动、网页端表格复制转换: 标题 数据一 数据二 表格测试 943 baka Ctrl + Shift + Q: 引用 ： 连续按两下Enter可以退出引用 Enter+Enter Shift Ctrl I: 图片: 基本的不带快捷键Markdown书写演示部分功能需要在 文件- 偏好设置 中开启才能使用 `连续输入: 1234567```javapublic class Hello&#123; public static void main(String[] args)&#123; System.out.println(&quot;Hello World!&quot;); &#125;&#125; 无序、有序、任务列表 : JAVA PYTHON CSS 按下Tab可进入下一级列表 HTML 双击Enter退出列表 任务列表可以勾选选项 游戏 女人 代码]]></content>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础语法与数据类型]]></title>
    <url>%2F2019%2F04%2F12%2F%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一、基本类型 byte/8 char/16 short/16 int/32 float/32 long/64 boolean/ 包装类型基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。 12Integer x = 2; // 装箱int y = x; // 拆箱 缓存池new Integer(123) 与 Integer.valueOf(123) 的区别在于： new Integer(123) 每次都会新建一个对象； Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。 123456Integer x = new Integer(123); Integer y = new Integer(123);System.out.println(x == y); // false,x与y为不同对象的引用Integer z = Integer.valueOf(123);Integer k = Integer.valueOf(123);System.out.println(z == k); // true,x与y为缓冲池中同一对象的引用 valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) //判断i是否在-128~127之间 return IntegerCache.cache[i + (-IntegerCache.low)]; //为true返回缓冲池中对象 return new Integer(i); //为false返回一个新对象&#125; 在 Java 8 中，Integer 缓存池的大小默认为 -128~127。 编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。 123Integer m = 123;Integer n = 123;System.out.println(m == n); // true 基本类型对应的缓冲池如下： boolean values true and false all byte values short values between -128 and 127 int values between -128 and 127 char in the range \u0000 to \u007F 在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。 二、StringString在java中表示不可变字符串。 1234567public final class String //String不可继承 implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; private final byte[] value; //value初始化之后不能再引用其他数组,保证String数据不可变 private final byte coder; //指定编码&#125; value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。 String Pool字符串常量池(String Pool)保存所有字符串的字面量，这些字面量在编译时确定。 intern()方法当一个String对象调用intern()方法时,如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。 1234567String s1 = new String(&quot;aaa&quot;);String s2 = new String(&quot;aaa&quot;);System.out.println(&quot;s1 == s2&quot;); false,s1,s2引用堆中不同对象 String s3 = s1.intern(); StringPool中先添加字符串&quot;aaa&quot;,然后s3引用该字符串String s4 = s1.intern(); StringPool已经存在字符串&quot;aaa&quot;,s4直接引用该字符串System.out.println(s3==s4); true,s3,s4引用的是StringPool中同一个字符串&quot;aaa&quot; 字面量形式创建字符串如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中，区别于使用new在堆中创建对象 123String s5 = &quot;bbb&quot;; StringPool新增字符串&quot;bbb&quot;String s6 = &quot;bbb&quot;; 引用StringPool中的&quot;bbb&quot;System.out.println(s5 == s6); // true new String(“abc”)如果StringPool中没有“abc”，这种方式会创建两个字符串对象: “abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象 “abc” 堆中创建一个字符串对象“abc”。 String构造函数源码以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。 1234public String(String original) &#123; this.value = original.value; this.hash = original.hash;&#125; String，StringBuffer，StringBuilder1. 可变性 String 不可变 StringBuffer 和 StringBuilder 可变 2. 线程安全 String 不可变，因此是线程安全的 StringBuilder 线程不安全 StringBuffer 是线程安全的，内部使用 synchronized 进行同步 三、运算隐式类型转换隐式类型转换指的是低精度数据类型转换为转换为高精度数据类型, 不会损失精度，如short(16)–&gt; int(32)，int (32)–&gt; double(64)，数据类型的精度可以理解为在内存中占的字节长度。 byte/8 char/16 short/16 int/32 float/32 long/64 boolean/ 强制类型转换(向下转型)强制类型转换指的是将高精度数据类型强制转换为低精度数据类型，会损失精度，如int(32)–&gt;short(16)，double(64)–&gt;int(32） 一个例子 12double value = 3.1416926;int value1 = (int) value; //double类型强制转换为int型 可想而知，由于double类型为64位，而int类型为32位，用一个int类型变量去接收double类型变量，只能接收到低32位，而高32位的数据便丢失了，也就是损失了精度 switch语句从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。 123456789String s = "a";switch (s) &#123; case "a": System.out.println("aaa"); break; case "b": System.out.println("bbb"); break;&#125; 四、关键字final1.final修饰数据声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。 对于基本类型，final 使数值不变； 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。 1234final int value = 1; value的值将不能修改final Student stu = new Student(); stu将不能引用其他Student对象stu.name="傻狍子"; stu本身数据可以修改 2. final修饰方法 声明方法不能被子类重写。 1public final viod Method()&#123;&#125; //Method方法不能被重写 private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。 3. final修饰类 声明类不允许被继承。 1public final class String&#123;&#125; //String类不可被继承 static1. 静态变量 静态变量：直接属于类，在类初始化时被初始化，通过类名直接访问 实例变量：属于实例，与实例一起初始化与销毁 1234567891011public class Student &#123; private int age; // 实例变量 private static int studentNumber; // 静态变量 public static void main(String[] args) &#123; Student student = new Student(); int age = student.getAge(); int number = Student.studentNumber; //类名直接访问 &#125; ...&#125; 2. 静态方法 静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。 只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。 123456public class Student &#123; private static int studentNumber; public static int getStudentNummber()&#123; //返回学生总数 return studentNumber; &#125;&#125; 3. 静态语句块 静态语句块只在类初始化时运行一次。 123456public class Student &#123; static &#123; System.out.println("加载学生类"); &#125; &#125; 4. 静态内部类 非静态内部类依赖于外部类的实例，而静态内部类不需要。 12345678910111213141516public class OuterClass &#123; class InnerClass &#123; &#125; static class StaticInnerClass &#123; &#125; public static void main(String[] args) &#123; OuterClass outerClass = new OuterClass(); //使用外部类对象.new 静态内部类()的语法来创建静态内部类对象 InnerClass innerClass = outerClass.new InnerClass(); //静态内部类可以直接创建 StaticInnerClass staticInnerClass = new StaticInnerClass(); &#125;&#125; 静态内部类不能访问外部类的非静态的变量和方法。 5. 静态导包 静态导入是 Java 5 的新增特性，用来导入类的静态变量和静态方法。 一般我们导入类都这样写： 1import packageName.className; // 导入某个特定的类 或 1import packageName.*; // 导入包中的所有类 而静态导入可以这样写： 1import static packageName.className.methonName; // 导入某个特定的静态方法 或 1import static packageName.className.*; // 导入类中的所有静态成员 导入后，可以在当前类中直接用方法名调用静态方法，不必再用 className.methodName 来访问。 对于使用频繁的静态变量和静态方法，可以将其静态导入。静态导入的好处是可以简化一些操作，例如输出语句 System.out.println(); 中的 out 就是 System 类的静态变量，可以通过 import static java.lang.System.*; 将其导入，下次直接调用 out.println() 就可以了。 请看下面的代码： 1234567import static java.lang.System.*;import static java.lang.Math.random;public class Demo &#123; public static void main(String[] args) &#123; out.println(&quot;产生的一个随机数：&quot; + random()); &#125;&#125; 运行结果： 产生的一个随机数：0.05800891549018705 6. 初始化顺序 静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。 12345678public static String staticField = "静态变量"; //最先执行static &#123; System.out.println("静态语句块"); //其次&#125;public String field = "实例变量"; //其次&#123; System.out.println("普通语句块"); //其次&#125; 最后才是构造函数的初始化。 123public InitialOrderTest() &#123; System.out.println("构造函数"); //最后执行&#125; 存在继承的情况下，初始化顺序为： 父类（静态变量、静态语句块） 子类（静态变量、静态语句块） 父类（实例变量、普通语句块） 父类（构造函数） 子类（实例变量、普通语句块） 子类（构造函数） 参考资料 : https://github.com/CyC2018/CS-Notes]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 齐阳的个人博客主页Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
