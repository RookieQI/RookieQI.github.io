<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[继承与多态]]></title>
    <url>%2F2019%2F04%2F13%2F%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[Java继承与多态1.继承java只支持单继承 2.super关键字super 关键字的功能： 与this不同，this表示当前对象，super表示父类对象 调用父类中声明为 private 的变量。 调用已经覆盖了的方法。 作为方法名表示父类构造方法。 调用隐藏变量和被覆盖的方法12345678910111213141516171819202122232425262728class People&#123; private String str = "学无止境"; public String getStr() &#123; return str; &#125; public void learn()&#123; System.out.println("人可以靠学习充实自己"); &#125;&#125;class Student extends People&#123; @OverRide public void learn()&#123; super.learn(); // 调用父类的方法 // 通过 getter 方法调用父类隐藏变量 System.out.println("Please remember: " + super.getDesc()); &#125;&#125;public class Demo&#123; public static void main(String[] args) &#123; Student student = new Student(); student.learn(); &#125;&#125;/*运行结果：人可以靠学习充实自己Please remember:学无止境*/ learn() 方法也可以定义在某些祖先类中，Java 具有追溯性，会一直向上找，直到找到该方法为止。 通过 super 调用父类的隐藏变量，必须要在父类中声明 getter 方法，因为声明为 private 的数据成员对子类是不可见的。 重写与重载1. 重写（Override） 存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。 下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中： 重写使用 @Override 注解 子类方法访问权限为 public，大于父类的 protected。 子类的返回类型为 ArrayList，是父类返回类型 List 的子类。 子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。 123456789101112class SuperClass &#123; protected List&lt;Integer&gt; func() throws Throwable &#123; return new ArrayList&lt;&gt;(); &#125;&#125;class SubClass extends SuperClass &#123; @Override public ArrayList&lt;Integer&gt; func() throws Exception &#123; return new ArrayList&lt;&gt;(); &#125;&#125; 2. 重载（Overload） 存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。 需要特别注意的是，返回值不同，其它都相同不算是重载。 2.多态多态的定义多态是指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用） 实现多态的技术实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法 多态的作用消除类型之间的耦合关系 多态存在的必要条件 要有继承 要有重写 父类引用指向子类对象 Java中多态的实现方式实现接口，继承父类方法进行重写，同一个类中进行方法重载 instanceof 运算符作用：java 中的instanceof运算符通过返回一个布尔值来指出，这个对象是否是这个特定类或者是它的子类的一个实例 该运算符语法: Object object.intanceof(Class classname/Interface interfacename),返回值有以下结果: 如果对象object是类Classname或者其子类的实例,返回true; 如果对象object实现了interfacename,返回true; 其他情况返回false 一个简单的例子 12345678910111213141516171819202122232425262728293031323334353637interface Learn&#123; void learn();&#125;class People implements Learn&#123; @Override public void learn()&#123; System.out.println("一个人在学习..."); &#125;&#125;class Student extends People&#123; @Override public void learn()&#123; System.out.println("一个学生在学习..."); &#125;&#125;class Teacher extends People&#123;&#125;public class Text&#123; public static void main(String[] args)&#123; People people = new Student(); //定义一个实际类型为Student的引用people if(people instanceof Object) &#123; System.out.println("people是一个对象");&#125; //true，people是Object的 if(people instanceof People) &#123; System.out.println("people是一个人");&#125; //true,people是People的子类 if(people instanceof Student) &#123;System.out.println("people是一个学生");&#125; //true,people本身是Student类的对象 if(people instanceof Teacher) &#123;System.out.println("people是一个教室");&#125; //false,people与Teather都是People的子类,属于平行关系 if(people instanceof Learn) &#123;System.out.println("people可以学习")&#125; &#125;&#125;//运行结果people是一个对象people是一个人people是一个学生people可以学习 多态对象的类型转换假设有以下继承关系 12345678910111213141516171819class Animal&#123; public void shout()&#123; System.out.println("A animal is shouting..."); &#125;&#125;class Dog extends Animal&#123; @Override public void shout() &#123; System.out.println("wang!"); &#125;&#125;class Cat extends Animal&#123; @Override public void shout() &#123; System.out.println("miao!"); &#125;&#125; 1.安全的向上转型继承链下级类型的向上级转型，不存在风险，多态的一种体现 123456public static void main(String[] args)&#123; Dog dog = new Dog(); Animal animal = dog; //发生了隐式的向上转型 //向上转型会损失一些数据与方法，例如animal将无法访问Dog类的新增方法，只能访问 Dog类中从Animal类中继承来的方法&#125; 不安全的强制转型继承链上次的类型向下级转型，存在风险 1234public static void main(String[] args)&#123; Animal animal = new Dog(); Cat cat = (Cat)animal; //这里能顺利通过编译,因为编译器会将animal看作Animala类型的引用,但在运行期,animal的实际类型被确定为Dog,将Dog类型强行转换为Cat类型会报错&#125; 使用instanceof进行安全的强制类型转换123456789101112131415161718192021222324252627public class Demo &#123; public static void main(String[] args) &#123; Animal animal = new Dog(); //代码1 animal.shout(); //根据多态,Animal类型引用animal可以调用Dog类对象的shout()方法 /* 但有一点值得注意，由于多态的动态绑定，animal的实际类型是在运行时才确定的， 也就是说，当我们无法看见代码1时,我们就无法事先知道animal到底指向的是 Dog对象还是Cat对象,此时若贸然执行animal.shout(),执行的结果必定也是未知的(很 简单，如果animal实际对象类型是Dog，则输出"wang!",如果是Cat,则执行"miao!",但 我们并不知道实际对象类型) */ /*为了解决上述情况，我们可以在执行animal.shout()语句前，先用instanceof运算符 判断出animal的类型，再根据相应的类型执行相应的动作*/ if(animal instanceof Dog)&#123; //如果animal是Dog类的实例 Dog dog = (Dog)animal; //将animal强制转型为Dog类型 dog1.shout(); &#125; if(animal instanceof Cat)&#123; //如果animal是Cat类的实例 Cat cat = (Cat)amimal; //将animal强制转型为Cat类型 cat.shout(); &#125; &#125;&#125;/*执行结果wang!wang!*/]]></content>
  </entry>
  <entry>
    <title><![CDATA[Typora基本用法]]></title>
    <url>%2F2019%2F04%2F12%2FTypora%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Typora编辑器 —-书写即为美学官方网站:https://www.typora.io/ 支持平台 Windows Linux OSX 特点: 完美支持GitHub的Markdown语法; 人性化的书写方式: 表格的书写、挪动; 图片、超链接、网页表格复制; 目录生成; 支持LeTex公式书写; 支持Flowchart,Mermaid等流程图绘制; emoji,高亮,备注,上标,下标等书写; 生成网页,pdf,图片,甚至word,LeTex等格式。 基本的带快捷键的Markdown书写演示Ctrl+0到Ctrl4:普通文本、一级~四级标题; Ctrl+B : 加粗,加粗测试; Ctrl+I : 斜体,斜体测试; Ctrl+U: 下划线,下划线测试； Shift Alt+5: 删除线,删除线测试； 单机一下 ` : 行内代码块; Ctrl+K : 超链接,超链接测试;还支持文章内锚点,请Ctrl点击此处–&gt;第二节； Ctrl+T : 表格,支持拖拽移动、网页端表格复制转换: 标题 数据一 数据二 表格测试 943 baka Ctrl + Shift + Q: 引用 ： 连续按两下Enter可以退出引用 Enter+Enter Shift Ctrl I: 图片: 基本的不带快捷键Markdown书写演示部分功能需要在 文件- 偏好设置 中开启才能使用 `连续输入: 1234567```javapublic class Hello&#123; public static void main(String[] args)&#123; System.out.println(&quot;Hello World!&quot;); &#125;&#125; 无序、有序、任务列表 : JAVA PYTHON CSS 按下Tab可进入下一级列表 HTML 双击Enter退出列表 任务列表可以勾选选项 游戏 女人 代码]]></content>
  </entry>
  <entry>
    <title><![CDATA[博客介绍]]></title>
    <url>%2F2019%2F04%2F12%2F%E5%8D%9A%E5%AE%A2%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[#作者的一些话 您好!欢迎您浏览本博客,我是本博客的作者91MrQi，如果您也是一位 编程的爱好者,我想我们可以做朋友… ##博客主要内容 本博客主要是对作者在编程学习过程中的一些知识的整理,其中主要有: JAVA SE部分 JAVA 概述 JAVA 基础语法与数据类型 JAVA 继承与多态 JAVA 容器 JAVA 异常 JAVA I/O JAVA 泛型 JAVA 并发 JAVA 虚拟机]]></content>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础语法与数据类型]]></title>
    <url>%2F2019%2F04%2F12%2FJava%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一、基本类型 byte/8 char/16 short/16 int/32 float/32 long/64 boolean/ 包装类型基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。 12Integer x = 2; // 装箱int y = x; // 拆箱 缓存池new Integer(123) 与 Integer.valueOf(123) 的区别在于： new Integer(123) 每次都会新建一个对象； Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。 123456Integer x = new Integer(123); Integer y = new Integer(123);System.out.println(x == y); // false,x与y为不同对象的引用Integer z = Integer.valueOf(123);Integer k = Integer.valueOf(123);System.out.println(z == k); // true,x与y为缓冲池中同一对象的引用 valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) //判断i是否在-128~127之间 return IntegerCache.cache[i + (-IntegerCache.low)]; //为true返回缓冲池中对象 return new Integer(i); //为false返回一个新对象&#125; 在 Java 8 中，Integer 缓存池的大小默认为 -128~127。 编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。 123Integer m = 123;Integer n = 123;System.out.println(m == n); // true 基本类型对应的缓冲池如下： boolean values true and false all byte values short values between -128 and 127 int values between -128 and 127 char in the range \u0000 to \u007F 在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。 二、StringString在java中表示不可变字符串。 1234567public final class String //String不可继承 implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; private final byte[] value; //value初始化之后不能再引用其他数组,保证String数据不可变 private final byte coder; //指定编码&#125; value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。 String Pool字符串常量池(String Pool)保存所有字符串的字面量，这些字面量在编译时确定。 intern()方法当一个String对象调用intern()方法时,如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。 1234567String s1 = new String(&quot;aaa&quot;);String s2 = new String(&quot;aaa&quot;);System.out.println(&quot;s1 == s2&quot;); false,s1,s2引用堆中不同对象 String s3 = s1.intern(); StringPool中先添加字符串&quot;aaa&quot;,然后s3引用该字符串String s4 = s1.intern(); StringPool已经存在字符串&quot;aaa&quot;,s4直接引用该字符串System.out.println(s3==s4); true,s3,s4引用的是StringPool中同一个字符串&quot;aaa&quot; 字面量形式创建字符串如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中，区别于使用new在堆中创建对象 123String s5 = &quot;bbb&quot;; StringPool新增字符串&quot;bbb&quot;String s6 = &quot;bbb&quot;; 引用StringPool中的&quot;bbb&quot;System.out.println(s5 == s6); // true new String(“abc”)如果StringPool中没有“abc”，这种方式会创建两个字符串对象: “abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象 “abc” 堆中创建一个字符串对象“abc”。 String构造函数源码以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。 1234public String(String original) &#123; this.value = original.value; this.hash = original.hash;&#125; String，StringBuffer，StringBuilder1. 可变性 String 不可变 StringBuffer 和 StringBuilder 可变 2. 线程安全 String 不可变，因此是线程安全的 StringBuilder 线程不安全 StringBuffer 是线程安全的，内部使用 synchronized 进行同步 三、运算隐式类型转换隐式类型转换指的是低精度数据类型转换为转换为高精度数据类型, 不会损失精度，如short(16)–&gt; int(32)，int (32)–&gt; double(64)，数据类型的精度可以理解为在内存中占的字节长度。 byte/8 char/16 short/16 int/32 float/32 long/64 boolean/ 强制类型转换(向下转型)强制类型转换指的是将高精度数据类型强制转换为低精度数据类型，会损失精度，如int(32)–&gt;short(16)，double(64)–&gt;int(32） 一个例子 12double value = 3.1416926;int value1 = (int) value; //double类型强制转换为int型 可想而知，由于double类型为64位，而int类型为32位，用一个int类型变量去接收double类型变量，只能接收到低32位，而高32位的数据便丢失了，也就是损失了精度 switch语句从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。 123456789String s = "a";switch (s) &#123; case "a": System.out.println("aaa"); break; case "b": System.out.println("bbb"); break;&#125; 四、关键字final1.final修饰数据声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。 对于基本类型，final 使数值不变； 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。 1234final int value = 1; value的值将不能修改final Student stu = new Student(); stu将不能引用其他Student对象stu.name="傻狍子"; stu本身数据可以修改 2. final修饰方法 声明方法不能被子类重写。 1public final viod Method()&#123;&#125; //Method方法不能被重写 private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。 3. final修饰类 声明类不允许被继承。 1public final class String&#123;&#125; //String类不可被继承 static1. 静态变量 静态变量：直接属于类，在类初始化时被初始化，通过类名直接访问 实例变量：属于实例，与实例一起初始化与销毁 1234567891011public class Student &#123; private int age; // 实例变量 private static int studentNumber; // 静态变量 public static void main(String[] args) &#123; Student student = new Student(); int age = student.getAge(); int number = Student.studentNumber; //类名直接访问 &#125; ...&#125; 2. 静态方法 静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。 只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。 123456public class Student &#123; private static int studentNumber; public static int getStudentNummber()&#123; //返回学生总数 return studentNumber; &#125;&#125; 3. 静态语句块 静态语句块只在类初始化时运行一次。 123456public class Student &#123; static &#123; System.out.println("加载学生类"); &#125; &#125; 4. 静态内部类 非静态内部类依赖于外部类的实例，而静态内部类不需要。 12345678910111213141516public class OuterClass &#123; class InnerClass &#123; &#125; static class StaticInnerClass &#123; &#125; public static void main(String[] args) &#123; OuterClass outerClass = new OuterClass(); //使用外部类对象.new 静态内部类()的语法来创建静态内部类对象 InnerClass innerClass = outerClass.new InnerClass(); //静态内部类可以直接创建 StaticInnerClass staticInnerClass = new StaticInnerClass(); &#125;&#125; 静态内部类不能访问外部类的非静态的变量和方法。 5. 静态导包 在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。 1import static com.xxx.ClassName 6. 初始化顺序 静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。 12345678public static String staticField = "静态变量"; //最先执行static &#123; System.out.println("静态语句块"); //其次&#125;public String field = "实例变量"; //其次&#123; System.out.println("普通语句块"); //其次&#125; 最后才是构造函数的初始化。 123public InitialOrderTest() &#123; System.out.println("构造函数"); //最后执行&#125; 存在继承的情况下，初始化顺序为： 父类（静态变量、静态语句块） 子类（静态变量、静态语句块） 父类（实例变量、普通语句块） 父类（构造函数） 子类（实例变量、普通语句块） 子类（构造函数） 五、 面向对象基本特性1.继承java只支持单继承 2.super关键字super 关键字的功能： 与this不同，this表示当前对象，super表示父类对象 调用父类中声明为 private 的变量。 调用已经覆盖了的方法。 作为方法名表示父类构造方法。 调用隐藏变量和被覆盖的方法1234567891011121314151617181920212223242526272829class People&#123; private String str = "学无止境"; public String getStr() &#123; return str; &#125; public void learn()&#123; System.out.println("人可以靠学习充实自己"); &#125;&#125;class Student extends People&#123; @OverRide public void learn()&#123; super.learn(); // 调用父类的方法 // 通过 getter 方法调用父类隐藏变量 System.out.println("Please remember: " + super.getDesc()); &#125;&#125;public class Demo&#123; public static void main(String[] args) &#123; Student student = new Student(); student.learn(); &#125;&#125;/*运行结果：人可以靠学习充实自己Please remember:学无止境*/ learn() 方法也可以定义在某些祖先类中，Java 具有追溯性，会一直向上找，直到找到该方法为止。 通过 super 调用父类的隐藏变量，必须要在父类中声明 getter 方法，因为声明为 private 的数据成员对子类是不可见的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[MarkDown编写文章]]></title>
    <url>%2F2019%2F04%2F12%2FMarkDown%E7%BC%96%E5%86%99%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[12345public class hello&#123; public static void main(String[] args)&#123; System.out.println("hello world!");&#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 齐阳的个人博客主页Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
