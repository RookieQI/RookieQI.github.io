<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java完整学习路线]]></title>
    <url>%2F2019%2F04%2F15%2FJava%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[Java完整学习路线JavaSE(第一阶段) 技术名称 技术内容 Java基础语法 Java语法格式，常量和变量，变量的作用域，方法和方法的重载，运算符，程序流程控制，数组和操作数组的类，对数组循环遍历以及针对数组的常用查找、排序算法原理，最后使用Java程序进行功能实现。 面向对象编程 理解对象的本质，以及面向对象，类与对象之间的关系，如何用面向对象的思想分析和解决显示生活中的问题，并java程序的手段编写出来。如何设计类，设计类的基本原则，类的实例化过程，类元素：构造函数、this关键字、方法和方法的参数传递过程、static关键字、内部类，Java的垃圾对象回收机制。对象的三大特性：封装、继承和多态。子类对象的实例化过程、方法的重写和重载、final关键字、抽象类、接口、继承的优点和缺点。 对象的多态性：子类和父类之间的转换、父类纸箱子类的引用、抽象类和接口在多态中的应用、多态优点。常用设计模式如单利、模版等模式。什么是异常 异常的捕捉和抛出 异常捕捉的原则 finally的使用，package的应用 import关键字。 多线程应用 多线程的概念，如何在程序中创建多线程(Thread、Runnable)，线程安全问题，线程的同步，线程之间的通讯、死锁问题的剖析。 javaAPI详解 JavaAPI介绍、String和StringBuffer、各种基本数据类型包装类，System和Runtime类，Date和DateFomat类等。常用的集合类使用如下：Java Collections Framework：Collection、Set、List、ArrayList、Vector、LinkedList、Hashset、TreeSet、Map、HashMap、TreeMap、Iterator、Enumeration等常用集合类API。 IO技术 什么是IO，File及相关类，字节流InputStream和OutputStream，字符流Reader和Writer，以及相应缓冲流和管道流，字节和字符的转化流，包装流，以及常用包装类使用，分析java的IO性能。 网络编程 Java网络编程，网络通信底层协议TCP/UDP/IP，Socket编程。网络通信常用应用层协议简介：HTTP、FTP等，以及WEB服务器的工作原理。 java高级特性 递归程序，Java的高级特性：反射、代理和泛型、枚举、Java正则表达式API详解及其应用。 (数据库技术) 第二阶段 技术名称 技术内容 Oracle 基础管理 Oracle背景简介，数据库的安装，数据库的用户名和密码，客户端登录数据库服务SQLPLUS，数据库基本概。 SQL语句 数据库的创建，表的创建，修改，删除，查询，索引的创建，主从表的建立，数据控制授权和回收，事务控制，查询语句以及运算符的详解，sql中的函数使用。 多表连接和子查询 等值和非等值连接，外连接，自连接；交叉连接，自然连接，using子句连接，完全外连接和左右外连接，子查询使用以及注意事项。 触发器、存储过程 触发器和存储过程使用场合， 通过实例进行详解。 数据库设计优化 WHERE子句中的连接顺序，选择最有效率的表名顺序，SELECT子句中避免使用 ‘ * ‘ 计算记录条数等等。 数据备份与移植 移植技巧，备份方案；导入导出等。 JDBC技术(第三阶段) 技术名称 技术内容 JDBC基础 JDBC Connection、Statement、PreparedStatement、CallableStatement、ResultSet等不同类的使用。 连接池技术 了解连接池的概念，掌握连接池的建立、治理、关闭和配置。 ORM与DAO封装 对象关系映射思想，jdbc的dao封装，实现自己的jdbc。 Web基础技术(第四阶段) 技术名称 技术内容 Xml技术 使用jdom和dom4j来对xml文档的解析和生成操作，xml 的作用和使用场合。 html/css Java掌握基本的html标签的格式和使用，css层叠样式表对div的定义，实现对网站布局的基本实现。 Javascript 了解javascript的基本语法以及相关函数的使用，并结合html页面实现流程控制和页面效果展示。什么是异常 异常的捕捉和抛出 异常捕捉的原则 finally的使用，package的应用 import关键字。 jsp/servlet Servlet和SP 技术、上传下载、 Tomcat 服务器技术、servlet 过滤器和监听器。 jstl和EL JSTL核心标签库、函数标签库、格式化标签库、自定义标签技术、EL表达式在jsp页面的使用。 ajax及框架技术 了解和属性原生态的ajax的使用，ajax使用的场合，使用ajax的好处，ajax框架jquery渲染页面效果和相关的强大的第三方类库，dwr如何和后台服务进行数据传输，以及页面逻辑控制等。 JSON高级应用 Java使用json支持的方式对字符串进行封装和解析，实现页面和java后台服务的数据通信。 Fckeditor编辑器 FCKEditor在线编辑器技术、配置、处理图片和文件上传。 javaMail技术 了解域名解析与MX记录、电子邮件工作原理、邮件传输协议：SMTP、POP3、IMAP、邮件组织结构：RFC822邮件格式、MIME协议、邮件编码、复合邮件结构分析、JavaMail API及其体系结构、编程创建邮件内容：简单邮件内容、包含内嵌图片的复杂邮件、包含内嵌图片和附件的复杂邮件。 JfreeChart报表 统计报表；图表处理。 BBS项目实战 采用Jquery+dwr+jsp+servlet+Fckeditor+JfreeChart+tomcat+jdbc(oracle) 完成BBS项目的实战。 （web主流框架技术(项目实战)）第五阶段 技术名称 技术内容 struts2.x struts2框架的工作原理和架构分析，struts-default.xml与default.properties文件的作用，struts。Xml中引入多个配置文件。OGNL表达式、Struts2 UI和非UI标签、输入校验、使用通配符定义action、动态方法调用、多文件上传、自定义类型转换器、为Action的属性注入值、自定义拦截器、异常处理、使用struts2实现的CRUD操作的案例。 hibernate3.x Hibernate应用开发基础； ORM基础理论； 关系映射技术； 性能调优技术； 性能优化 一级缓存 二级缓存 查询缓存 事务与并发 悲观锁、乐观锁。 spring3.x Spring IoC技术； Spring AOP技术； Spring 声明事务管理； Spring 常用功能说明，spring3.0的新特性， Spring整合struts2和hibernate3的运用。 Log4j和Junit Logging API； JUnit单元测试技术； 压力测试技术：badboy 进行测试计划跟踪获取以及JMeter压力测试。 在线支付技术 完成支付宝的支付接口的在线支付功能。 电子商务网实战 采用spring3+hibernate3+struts2+jquery+dwr+FckEditor+tomcat 完成电子商务网站实战开发。 web高级进阶(项目实战)第六阶段 技术名称 技术内容 openJpa技术 JPA介绍及开发环境搭建、单表实体映射、一对多/多对一、一对一、多对多关联、实体继承、复合主键、JPQL语句、EntityManager API、事务管理，了解一下jpa2.0的新特性以及应用。 lucene搜索引擎 了解全文搜索原理、全文搜索引擎、什么是OSEM、OSEM框架Compass、基于使用Lucene使用Compass实现全文增量型索引创建和搜索、探索Lucene 3.0以及API。 电子商务网重构 此项目采用了Lucene+compass+openJpa+上一版电子商务网站的技术进行重构。 Excel/PDF文档处理技术 ava对excel和pdf文档分别利用poi和itext来进行解析和生成。此技术在企业级系统的报表中经常使用。 OA工作流技术JBPM 工作流是什么、JBPM介绍、JBPM的主要用法、各类节点的用法、任务各种分派方式、JBPM的整体架构原理、工作流定义模型分析、运行期工作流实例模型分析、数据库表模型分析、流程定义管理、流程实例监控、对JBPM的相关接口进行封装，构建自己的工作流应用平台等。 WebService技术 WebService技术原理、WebService技术的应用、Soap服务的创建与管理、WSDL描述文档规范、UDDI 注册中心运行原理;使用Axis和Xfire创建WEB服务、Webservice客户端的编写、使用TCPMonitor监听SOAP协议、异构平台的整合。 Linux技术 Linux 系统安装，卸载、linux 使用的核心思想、linux下的用户管理，文件管理,系统管理、程序的安装，使用，卸载。linux下作为server的基本应用：web服务器，j2ee服务器，ftp服务器的安装和项目的部署。 CRM项目实战 此项目能了解和熟悉客户关系管理的基本流程以及功能的实现，采用上面几个阶段学到的主流框架实现，同时加入了JBPM的技术。 大型高并发网站优化方案(项目实战)(第七阶段) 技术名称 技术内容 如何构建一个高性能网站详解 什么样的网站需要高性能，高性能的指标体系，构建高性能网站需要做哪些工作，注意哪些细节。 SSI技术 什么是SSI，使用他有什么好处，什么样的系统才使用SSI，SSI技术详解和使用，应用到项目中。 生成静态页技术 什么是静态页，为什么需要静态页以及带来的好处，生成静态页的模版技术Velocity和Freemark，生成静态页的访问规则等。 缓存技术 为什么使用缓存技术，oscache缓存技术的介绍和使用，memcached缓存技术的介绍和使用、两者缓存技术的比较和如何去使用。 经典web服务器 什么是web服务器，什么是javaweb服务器，他们存在什么关系，当前技术主流中常用的web服务器有哪些， web服务器apache和nginx的应用。 nginx架构实战 什么是反向代理，负载均衡以及集群，在nginx中如何实现这些高性能的系统架构。 清楚了完整的学习路线，你就可以正式踏上你的光头之旅啦!(滑稽~) 注明：此文章内容并非原创，转载自腾讯云]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F15%2FJava%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[Java异常如：文件找不到、网络连接失败、除0操作、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。 Java 异常的概念Java异常是一个描述在代码段中发生异常的对象，当发生异常情况时(如：文件找不到、网络连接失败、除0操作、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。)，一个代表该异常的对象被创建并且在导致该异常的方法中被抛出，而该方法可以选择自己处理异常或者传递该异常。 3. Java 异常类层次结构粉红色的是受检查的异常(checked exceptions),其必须被 try{}catch语句块所捕获,或者在方法签名里通过throws子句声明.另一类异常是运行时异常(runtime exceptions),需要程序员自己分析代码决定是否捕获和处理。而声明为Error的，则属于严重错误,需要根据业务信息进行特殊处理,Error不需要捕捉。中文示例： Exception 异常种类 异常描述 checked exceptions(受检查的异常) 必须被try{}catch语句块所捕获，或者在方法签名里通过throws子句声明 runtime exceptions(运行时异常) 需要程序员自己分析代码决定是否捕获和处理 Error(严重错误) 需要根据业务信息进行特殊处理，Error不需要捕捉也不能捕捉]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java容器]]></title>
    <url>%2F2019%2F04%2F13%2FJava%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Java容器1.概览Java容器只要包括collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。 Collection框架图 Collection种类 特点 TreeSet 基于红黑树实现，支持有序性操作，可以根据一个范围查找元素。查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 HashSet 基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。 LinkedHashSet 具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。 ArrayList(常用) 基于动态数组实现，支持随机访问，线程不安全 Vector 和 ArrayList 类似，但它是线程安全的 LinkedList 基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列 LinkedList： 可以用它来实现双向队列 PriorityQueue： 基于堆结构实现，可以用它来实现优先队列 Map框架图 Map种类 特点 TreeMap 基于红黑树实现 HashMap 基于哈希表实现 LinkedHashMap 使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序 HashTable 不支持使用，可以用ConcurrentHashMap替代 容器中的设计模式迭代器模式 Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。 从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。 123456List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add("a");list.add("b");for (String item : list) &#123; //增强for循环就是通过Collection的Iterator对象遍历元素 System.out.println(item);&#125; 适配器模式java.util.Arrays#asList() 可以把数组类型转换为 List 类型。 12@SafeVarargspublic static &lt;T&gt; List&lt;T&gt; asList(T... a) 应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。 12Integer[] arr = &#123;1, 2, 3&#125;;List list = Arrays.asList(arr); 也可以使用以下方式调用 asList()： 1List list = Arrays.asList(1, 2, 3); //自动装箱 源码分析ArrayList概览 实现了RandomAccess接口，支持快速存取访问 实现了Cloneable接口，支持克隆 实现了java.io.Serializable，支持序列化与反序列化 12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 基本属性12private transient Object[] elementData; //ArrayList底层由Obiect数组实现private int size; //elementData中实际存放元素的个数 构造器1234567891011public ArrayList(int initialCapacity) &#123; //传入指定容量 super(); //调用父类构造器 if (initialCapacity &lt; 0) //如果指定容量小于0，抛出参数不合法异常 throw new IllegalArgumentException(); this.elementData = new Object[initialCapacity]; &#125; //如果未指定容量则默认容量为10 public ArrayList() &#123; this(10); //调用ArrayList(int initialCapacity)&#123;&#125;构造器 &#125; modCountmodCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。 在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。 扩容12345678910111213141516171819202122232425private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //新容量为旧容量的1.5倍 if (newCapacity - minCapacity &lt; 0) //如果新容量仍然小于指定容量 newCapacity = minCapacity; //新容量等于指定容量 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 删除元素调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，ArrayList 删除元素的代价很高。 12345678910public E remove(int index) &#123; rangeCheck(index); //检查指定下标是否合理 modCount++; E oldValue = elementData(index); //获得要删除的元素 int numMoved = size - index - 1; //计算应移动的元素个数 if (numMoved &gt; 0) //如果需要移动的元素个数大于0,进行移动操作 System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // 将数组最后一个元素设为null return oldValue; //返回被删除的元素&#125; 序列化ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。 123456789101112131415161718private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; //记录操作前的modCount值 s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); //写出数组大小 //按正确顺序写出所有元素 for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; //如果序列化后modCount的值发生了改变，抛出异常 throw new ConcurrentModificationException(); &#125;&#125; 反序列化123456789101112131415161718192021private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // 读取大小和任何 s.defaultReadObject(); // 读入容量 s.readInt(); // 忽略 if (size &gt; 0) &#123; //类似clone()，根据大小而不是容量分配数组 ensureCapacityInternal(size); Object[] a = elementData; // 按指定顺序写入所有元素 for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125;&#125; Vector同步它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。 12345678910111213public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;&#125;public synchronized E get(int index) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); return elementData(index);&#125; 与 ArrayList 的比较 Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制； Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。 替代方案可以使用 Collections.synchronizedList(); 得到一个线程安全的 ArrayList。 12List&lt;String&gt; list = new ArrayList&lt;&gt;();List&lt;String&gt; synList = Collections.synchronizedList(list); //需要传入普通List对象 也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。 1List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); CopyOnWriteArrayList读写分离写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。 写操作需要加锁，防止并发写入时导致写入数据丢失。 写操作结束之后需要把原始数组指向新的复制数组。 123456789101112131415161718public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); //写操作之前加锁 try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); //复制数组 newElements[len] = e; //将e添加到复制数组的末尾 setArray(newElements); //将原始数组指向新的复制数组 return true; &#125; finally &#123; lock.unlock(); //不管写操作是否成功,最后都释放锁 &#125;&#125;final void setArray(Object[] a) &#123; array = a;&#125; 1234@SuppressWarnings("unchecked")private E get(Object[] a, int index) &#123; return (E) a[index];&#125; 适用场景优点：CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。 缺陷： 内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右； 数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。 所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景 LinkedList概览基于双向链表实现，使用 Node 存储链表节点信息。 12345private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev;&#125; 每个链表存储了 first 和 last 指针： 12transient Node&lt;E&gt; first;transient Node&lt;E&gt; last; 与 ArrayList 的比较 ArrayList 基于动态数组实现，LinkedList 基于双向链表实现； ArrayList 支持随机访问，LinkedList 不支持； LinkedList 在任意位置添加删除元素更快。 HashMap常用API 方法名 描述 final int hash(Object k) 由Key的hashCode计算hash public V put(Object key, Object value) 向HashMap中添加键值对 public V get(Object key) 由指定的key得到键值对 public boolean containsKey(Object key) 判断HashMap中是否包含键值对key public V remove(Object key) 移除键值对 public void clear() 清空HashMap … 存储结构内部包含了一个 Entry 类型(键值对)的数组 table。 1transient Entry[] table; Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值相同的 Entry。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; //key只能读取,不能更改,设置为常量 V value; Entry&lt;K,V&gt; next; //指向下一个键值对 int hash; //构造方法 Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; //注意:这里将当前键值对指向传入的键值对 key = k; hash = h; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; //重写equals()方法 public final boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) //如果o不是Map.Entry类型的实例，直接返回false return false; Map.Entry e = (Map.Entry)o; //将o强转为Map.Entry类型 //分别获得当前对象与待比较对象的key Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123; //如果两对象的key为'=='或者等价,再分别获得两对象的value Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) //如果两对象的value为'=='或者等价,返回true return true; &#125; return false; &#125; //重写hashCode() public final int hashCode() &#123; return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue()); &#125; //重写toString public final String toString() &#123; return getKey() + "=" + getValue(); &#125;&#125; PS : 从 JDK 1.8 开始，一个桶存储的链表长度大于 8 时会将链表转换为红黑树 2. 拉链法的工作原理1234HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();map.put("K1", "V1");map.put("K2", "V2");map.put("K3", "V3"); 新建一个 HashMap，默认大小为 16； 插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。 插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。 插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 &lt;K2,V2&gt; 前面。 (注意:K3虽然与K2的hashCode和桶下表相同，但他们的value不同，而根据HashMap的equals()方法，两个等价键值对必须key和value同时等价，所以K2与K3是不同的，这意味着K3能在K2已经存在的情况下顺利地插入桶下标为6的链表中) –-应该注意到链表的插入是以头插法方式进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在链表头部。 查找需要分成两步进行： 计算键值对所在的桶； 在链表上顺序查找，时间复杂度显然和链表的长度成正比。 计算 hash 值1234567891011121314151617final int hash(Object k) &#123; int h = hashSeed; if (0 != h &amp;&amp; k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h ^= k.hashCode(); This function ensures that hashCodes that differ only by constant multiples at each bit position have a bounded number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125;public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value);&#125; 确定桶下标很多操作都需要先确定一个键值对所在的桶下标。 12int hash = hash(key);int i = indexFor(hash, table.length); put 操作(插入键值对)1234567891011121314151617181920212223242526public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; // 键为 null 单独处理 if (key == null) return putForNullKey(value); int hash = hash(key); //通过hash方法对key的hashCode（）进行二次加工。减少碰撞 // 确定桶下标 int i = indexFor(hash, table.length); // 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; //for循环顺序便利桶下表为i的链表 Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); //记录一下 return oldValue; &#125; &#125; modCount++; //modcount与线程安全有关，在使用迭代器遍历HashMap时，一旦modCount发生变化就抛出异常 // 如果没有找到,插入新键值对 addEntry(hash, key, value, i); return null;&#125; HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。 1234567891011121314private V putForNullKey(V value) &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) &#123; //如果找到key为null的键值对,直接更新该键值对 V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(0, null, value, 0); return null;&#125; 使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。 1234567891011121314151617void addEntry(int hash, K key, V value, int bucketIndex) &#123; //如果HashMap的元素个数超过了最大容量并且桶下表不为null if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); //扩容 hash = (null != key) ? hash(key) : 0; //得到hash值 bucketIndex = indexFor(hash, table.length); //得到桶下标 &#125; createEntry(hash, key, value, bucketIndex); //调用插入键值对方法&#125;void createEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; // 头插法，链表头部指向新的键值对 table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); //调用Entry的构造方法,构造方法中的next = n 使 table[bucketIndex]自动指向e size++;&#125; PS : 构造方法 //构造方法 Entry(int h, K k, V v, Entry&lt;K,V&gt; n) { value = v; next = n; //注意:这里将当前键值对指向传入的键值对 key = k; hash = h; } get操作(通过key获得键值对)12345678910111213public V get(Object key)&#123; if(k == null) return getForNullKey(); int hash = hash(key)； //计算hash值 int i = indexFor(hash, table.length); //得到桶下标 for(Entry&lt;K,V&gt; e = table[i]; e != null;e = e.next)&#123; Object k; if(e.hash == hash &amp;&amp; ((k = e.key) == key || k.equals(key)))&#123; return e.value; &#125; &#125; return null;&#125; clear()1234567public void clear() &#123; modCount++; Entry[] tab = table; for (int i = 0; i &lt; tab.length; i++) tab[i] = null; //直接将每个table置为null，等待GC释放空间 size = 0;&#125; HashMap的其他方法实现方式都类似，就不再一一列举了。 HashMap与 HashTable 的比较 HashTable 使用 synchronized 来进行同步。 HashMap 可以插入键为 null 的 Entry。 HashMap 的迭代器是 fail-fast 迭代器。 HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。 ConcurrentHashMap存储结构123456static final class HashEntry&lt;K,V&gt; &#123; final int hash; final K key; volatile V value; volatile HashEntry&lt;K,V&gt; next;&#125; ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数(Segment 继承自 ReentrantLock)）。 默认的并发级别为 16，也就是说默认创建 16 个 Segment。 1static final int DEFAULT_CONCURRENCY_LEVEL = 16; size 操作每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。 1transient int count; 在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。 ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。 尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。 如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。 3. JDK 1.8 的改动JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。 JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。 并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。 LinkedHashMap存储结构继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。 1public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt; 内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。 1234//双向链表的头节点transient LinkedHashMap.Entry&lt;K,V&gt; head;//双向链表的尾节点transient LinkedHashMap.Entry&lt;K,V&gt; tail; accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。 1final boolean accessOrder; LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。 12void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;void afterNodeInsertion(boolean evict) &#123; &#125; afterNodeAccess()当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。 afterNodeInsertion()在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。 evict 只有在构建 Map 的时候才为 false，在这里为 true。 1234567void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest LinkedHashMap.Entry&lt;K,V&gt; first; if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123; K key = first.key; removeNode(hash(key), key, null, false, true); &#125;&#125; removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。 123protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123; return false;&#125; LRU 缓存以下是使用 LinkedHashMap 实现的一个 LRU 缓存： 设定最大缓存空间 MAX_ENTRIES 为 3； 使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序； 覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。 123456789101112131415161718192021class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123; private static final int MAX_ENTRIES = 3; protected boolean removeEldestEntry(Map.Entry eldest) &#123; return size() &gt; MAX_ENTRIES; &#125; LRUCache() &#123; super(MAX_ENTRIES, 0.75f, true); &#125;&#125;public static void main(String[] args) &#123; LRUCache&lt;Integer, String&gt; cache = new LRUCache&lt;&gt;(); cache.put(1, "a"); cache.put(2, "b"); cache.put(3, "c"); cache.get(1); cache.put(4, "d"); System.out.println(cache.keySet());&#125;[3, 1, 4] WeakHashMap存储结构WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。 WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。 1private static class Entry&lt;K,V&gt; extends WeakReference&lt;Object&gt; implements Map.Entry&lt;K,V&gt; ConcurrentCacheTomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。 ConcurrentCache 采取的是分代缓存： 经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）； 不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。 当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。 当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。 1234567891011121314151617181920212223242526272829303132public final class ConcurrentCache&lt;K, V&gt; &#123; private final int size; private final Map&lt;K, V&gt; eden; private final Map&lt;K, V&gt; longterm; public ConcurrentCache(int size) &#123; this.size = size; this.eden = new ConcurrentHashMap&lt;&gt;(size); this.longterm = new WeakHashMap&lt;&gt;(size); &#125; public V get(K k) &#123; V v = this.eden.get(k); if (v == null) &#123; v = this.longterm.get(k); if (v != null) this.eden.put(k, v); &#125; return v; &#125; public void put(K k, V v) &#123; if (this.eden.size() &gt;= size) &#123; this.longterm.putAll(this.eden); this.eden.clear(); &#125; this.eden.put(k, v); &#125;&#125; 声明 : 本文章借鉴于GitHub上，本人只是根据自身学习情况做了一些删改，并添加了一些自己的理解 原文链接 : https://github.com/CyC2018/CS-Notes]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaObject类详解]]></title>
    <url>%2F2019%2F04%2F13%2FJavaObject%E7%B1%BB%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Object类方法概览123456789101112131415161718192021public native int hashCode() //返回对象的散列值public boolean equals(Object obj) //判断两对象是否等价protected native Object clone() throws CloneNotSupportedExceptionpublic String toString() //返回对象字符串形式public final native Class&lt;?&gt; getClass() //获得类型的class对象protected void finalize() throws Throwable &#123;&#125;public final native void notify()public final native void notifyAll()public final native void wait(long timeout) throws InterruptedExceptionpublic final void wait(long timeout, int nanos) throws InterruptedExceptionpublic final void wait() throws InterruptedException equals()方法1.实现 检查是否为同一个对象的引用，如果是直接返回 true； 检查是否是同一个类型，如果不是，直接返回 false； 将 Object 对象进行转型； 判断每个关键域是否相等。 12345678910111213141516171819202122232425public class EqualExample &#123; private int x; private int y; private int z; public EqualExample(int x, int y, int z) &#123; this.x = x; this.y = y; this.z = z; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; //如果是同一对象的引用,返回ture if (o == null || getClass() != o.getClass()) return false; //如果o为null或者this对象的类型与o的类型不同,返回false EqualExample that = (EqualExample) o; //将o转型为EqualExample //对每个关键域进行比较 if (x != that.x) return false; if (y != that.y) return false; return z == that.z; &#125;&#125; 2.equals()与 “==” 运算符的区别表格表示 : 基本类型 引用类型 equals()方法 没有equals()方法 判断引用的类型是否等价 “==”运算符 判断两值是否相等 判断两个变量是否引用同一对象 代码示例 : 1234Integer x = new Integer(1);Integer y = new Integer(1);System.out.println(x.equals(y)); // x与y所引用的对象等价,返回trueSystem.out.println(x == y); // x与y引用的是不同对象,返回false 3.hashCode()hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。 4.toString()返回对象的字符串形式，一般需要在子类中重写 默认返回 ClassName@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。 声明 : 本文章借鉴于GitHub上，本人只是根据自身学习情况做了一些删改，并添加了一些自己的理解 原文链接 : https://github.com/CyC2018/CS-Notes]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承与多态]]></title>
    <url>%2F2019%2F04%2F13%2F%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[Java继承与多态1.继承java只支持单继承 2.super关键字super 关键字的功能： 与this不同，this表示当前对象，super表示父类对象 调用父类中声明为 private 的变量。 调用已经覆盖了的方法。 作为方法名表示父类构造方法。 调用隐藏变量和被覆盖的方法12345678910111213141516171819202122232425262728class People&#123; private String str = "学无止境"; public String getStr() &#123; return str; &#125; public void learn()&#123; System.out.println("人可以靠学习充实自己"); &#125;&#125;class Student extends People&#123; @OverRide public void learn()&#123; super.learn(); // 调用父类的方法 // 通过 getter 方法调用父类隐藏变量 System.out.println("Please remember: " + super.getDesc()); &#125;&#125;public class Demo&#123; public static void main(String[] args) &#123; Student student = new Student(); student.learn(); &#125;&#125;/*运行结果：人可以靠学习充实自己Please remember:学无止境*/ learn() 方法也可以定义在某些祖先类中，Java 具有追溯性，会一直向上找，直到找到该方法为止。 通过 super 调用父类的隐藏变量，必须要在父类中声明 getter 方法，因为声明为 private 的数据成员对子类是不可见的。 重写与重载1. 重写（Override） 存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。 下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中： 重写使用 @Override 注解 子类方法访问权限为 public，大于父类的 protected。 子类的返回类型为 ArrayList，是父类返回类型 List 的子类。 子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。 123456789101112class SuperClass &#123; protected List&lt;Integer&gt; func() throws Throwable &#123; return new ArrayList&lt;&gt;(); &#125;&#125;class SubClass extends SuperClass &#123; @Override public ArrayList&lt;Integer&gt; func() throws Exception &#123; return new ArrayList&lt;&gt;(); &#125;&#125; 2. 重载（Overload） 存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。 需要特别注意的是，返回值不同，其它都相同不算是重载。 2.多态多态的定义多态是指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用） 实现多态的技术实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法 多态的作用消除类型之间的耦合关系 多态存在的必要条件 要有继承 要有重写 父类引用指向子类对象 Java中多态的实现方式实现接口，继承父类方法进行重写，同一个类中进行方法重载 instanceof 运算符作用：java 中的instanceof运算符通过返回一个布尔值来指出，这个对象是否是这个特定类或者是它的子类的一个实例 该运算符语法: Object object.intanceof(Class classname/Interface interfacename),返回值有以下结果: 如果对象object是类Classname或者其子类的实例,返回true; 如果对象object实现了interfacename,返回true; 其他情况返回false 一个简单的例子 12345678910111213141516171819202122232425262728293031323334353637interface Learn&#123; void learn();&#125;class People implements Learn&#123; @Override public void learn()&#123; System.out.println("一个人在学习..."); &#125;&#125;class Student extends People&#123; @Override public void learn()&#123; System.out.println("一个学生在学习..."); &#125;&#125;class Teacher extends People&#123;&#125;public class Text&#123; public static void main(String[] args)&#123; People people = new Student(); //定义一个实际类型为Student的引用people if(people instanceof Object) &#123; System.out.println("people是一个对象");&#125; //true，people是Object的 if(people instanceof People) &#123; System.out.println("people是一个人");&#125; //true,people是People的子类 if(people instanceof Student) &#123;System.out.println("people是一个学生");&#125; //true,people本身是Student类的对象 if(people instanceof Teacher) &#123;System.out.println("people是一个教室");&#125; //false,people与Teather都是People的子类,属于平行关系 if(people instanceof Learn) &#123;System.out.println("people可以学习")&#125; &#125;&#125;//运行结果people是一个对象people是一个人people是一个学生people可以学习 多态对象的类型转换假设有以下继承关系 12345678910111213141516171819class Animal&#123; public void shout()&#123; System.out.println("A animal is shouting..."); &#125;&#125;class Dog extends Animal&#123; @Override public void shout() &#123; System.out.println("wang!"); &#125;&#125;class Cat extends Animal&#123; @Override public void shout() &#123; System.out.println("miao!"); &#125;&#125; 1.安全的向上转型继承链下级类型的向上级转型，不存在风险，多态的一种体现 123456public static void main(String[] args)&#123; Dog dog = new Dog(); Animal animal = dog; //发生了隐式的向上转型 //向上转型会损失一些数据与方法，例如animal将无法访问Dog类的新增方法，只能访问 Dog类中从Animal类中继承来的方法&#125; 不安全的强制转型继承链上次的类型向下级转型，存在风险 1234public static void main(String[] args)&#123; Animal animal = new Dog(); Cat cat = (Cat)animal; //这里能顺利通过编译,因为编译器会将animal看作Animala类型的引用,但在运行期,animal的实际类型被确定为Dog,将Dog类型强行转换为Cat类型会报错&#125; 使用instanceof进行安全的强制类型转换123456789101112131415161718192021222324252627public class Demo &#123; public static void main(String[] args) &#123; Animal animal = new Dog(); //代码1 animal.shout(); //根据多态,Animal类型引用animal可以调用Dog类对象的shout()方法 /* 但有一点值得注意，由于多态的动态绑定，animal的实际类型是在运行时才确定的， 也就是说，当我们无法看见代码1时,我们就无法事先知道animal到底指向的是 Dog对象还是Cat对象,此时若贸然执行animal.shout(),执行的结果必定也是未知的(很 简单，如果animal实际对象类型是Dog，则输出"wang!",如果是Cat,则执行"miao!",但 我们并不知道实际对象类型) */ /*为了解决上述情况，我们可以在执行animal.shout()语句前，先用instanceof运算符 判断出animal的类型，再根据相应的类型执行相应的动作*/ if(animal instanceof Dog)&#123; //如果animal是Dog类的实例 Dog dog = (Dog)animal; //将animal强制转型为Dog类型 dog1.shout(); &#125; if(animal instanceof Cat)&#123; //如果animal是Cat类的实例 Cat cat = (Cat)amimal; //将animal强制转型为Cat类型 cat.shout(); &#125; &#125;&#125;/*执行结果wang!wang!*/]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客的起点]]></title>
    <url>%2F2019%2F04%2F12%2F%E5%8D%9A%E5%AE%A2%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[#作者的一些话您好!欢迎您浏览本博客,我是本博客的作者91MrQi，如果您也是一位编程的爱好者,我想我们可以做朋友…以下是本博客所有文章的目录，您可以点击链接进入您想要浏览的文章知识繁多而复杂，在真正开始学习之前，我们应该知道我们究竟需要学什么，按照什么顺序学，我在这里整理了一套Java完整学习路线，强烈建议您在正式开始学习之前先熟悉以下Java的学习路线，再按照学习路线，分阶段地有条不紊地学习，祝你学习愉快! 正式学习前，请点击这里 : Java 完整学习路线 JAVA SE部分 JAVA 概述 JAVA 基础语法与数据类型 JAVA 继承与多态 JAVA Object类详解 JAVA 容器 JAVA 异常 JAVA I/O JAVA 泛型 JAVA 并发 JAVA 虚拟机 由于博客只搭建了几天，更多文章以后会陆续更新。。。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础语法与数据类型]]></title>
    <url>%2F2019%2F04%2F12%2FJava%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一、基本类型 byte/8 char/16 short/16 int/32 float/32 long/64 boolean/ 包装类型基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。 12Integer x = 2; // 装箱int y = x; // 拆箱 缓存池new Integer(123) 与 Integer.valueOf(123) 的区别在于： new Integer(123) 每次都会新建一个对象； Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。 123456Integer x = new Integer(123); Integer y = new Integer(123);System.out.println(x == y); // false,x与y为不同对象的引用Integer z = Integer.valueOf(123);Integer k = Integer.valueOf(123);System.out.println(z == k); // true,x与y为缓冲池中同一对象的引用 valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) //判断i是否在-128~127之间 return IntegerCache.cache[i + (-IntegerCache.low)]; //为true返回缓冲池中对象 return new Integer(i); //为false返回一个新对象&#125; 在 Java 8 中，Integer 缓存池的大小默认为 -128~127。 编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。 123Integer m = 123;Integer n = 123;System.out.println(m == n); // true 基本类型对应的缓冲池如下： boolean values true and false all byte values short values between -128 and 127 int values between -128 and 127 char in the range \u0000 to \u007F 在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。 二、StringString在java中表示不可变字符串。 1234567public final class String //String不可继承 implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; private final byte[] value; //value初始化之后不能再引用其他数组,保证String数据不可变 private final byte coder; //指定编码&#125; value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。 String Pool字符串常量池(String Pool)保存所有字符串的字面量，这些字面量在编译时确定。 intern()方法当一个String对象调用intern()方法时,如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。 1234567String s1 = new String("aaa");String s2 = new String("aaa");System.out.println("s1 == s2"); false,s1,s2引用堆中不同对象 String s3 = s1.intern(); StringPool中先添加字符串"aaa",然后s3引用该字符串String s4 = s1.intern(); StringPool已经存在字符串"aaa",s4直接引用该字符串System.out.println(s3==s4); true,s3,s4引用的是StringPool中同一个字符串"aaa" 字面量形式创建字符串如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中，区别于使用new在堆中创建对象 123String s5 = "bbb"; StringPool新增字符串"bbb"String s6 = "bbb"; 引用StringPool中的"bbb"System.out.println(s5 == s6); // true new String(“abc”)如果StringPool中没有“abc”，这种方式会创建两个字符串对象: “abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象 “abc” 堆中创建一个字符串对象“abc”。 String构造函数源码以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。 1234public String(String original) &#123; this.value = original.value; this.hash = original.hash;&#125; String，StringBuffer，StringBuilder1. 可变性 String 不可变 StringBuffer 和 StringBuilder 可变 2. 线程安全 String 不可变，因此是线程安全的 StringBuilder 线程不安全 StringBuffer 是线程安全的，内部使用 synchronized 进行同步 三、运算隐式类型转换隐式类型转换指的是低精度数据类型转换为转换为高精度数据类型, 不会损失精度，如short(16)–&gt; int(32)，int (32)–&gt; double(64)，数据类型的精度可以理解为在内存中占的字节长度。 byte/8 char/16 short/16 int/32 float/32 long/64 boolean/ 强制类型转换(向下转型)强制类型转换指的是将高精度数据类型强制转换为低精度数据类型，会损失精度，如int(32)–&gt;short(16)，double(64)–&gt;int(32） 一个例子 12double value = 3.1416926;int value1 = (int) value; //double类型强制转换为int型 可想而知，由于double类型为64位，而int类型为32位，用一个int类型变量去接收double类型变量，只能接收到低32位，而高32位的数据便丢失了，也就是损失了精度 switch语句从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。 123456789String s = "a";switch (s) &#123; case "a": System.out.println("aaa"); break; case "b": System.out.println("bbb"); break;&#125; 四、关键字final1.final修饰数据声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。 对于基本类型，final 使数值不变； 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。 1234final int value = 1; value的值将不能修改final Student stu = new Student(); stu将不能引用其他Student对象stu.name="傻狍子"; stu本身数据可以修改 2. final修饰方法 声明方法不能被子类重写。 1public final viod Method()&#123;&#125; //Method方法不能被重写 private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。 3. final修饰类 声明类不允许被继承。 1public final class String&#123;&#125; //String类不可被继承 static1. 静态变量 静态变量：直接属于类，在类初始化时被初始化，通过类名直接访问 实例变量：属于实例，与实例一起初始化与销毁 1234567891011public class Student &#123; private int age; // 实例变量 private static int studentNumber; // 静态变量 public static void main(String[] args) &#123; Student student = new Student(); int age = student.getAge(); int number = Student.studentNumber; //类名直接访问 &#125; ...&#125; 2. 静态方法 静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。 只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。 123456public class Student &#123; private static int studentNumber; public static int getStudentNummber()&#123; //返回学生总数 return studentNumber; &#125;&#125; 3. 静态语句块 静态语句块只在类初始化时运行一次。 123456public class Student &#123; static &#123; System.out.println("加载学生类"); &#125; &#125; 4. 静态内部类 非静态内部类依赖于外部类的实例，而静态内部类不需要。 12345678910111213141516public class OuterClass &#123; class InnerClass &#123; &#125; static class StaticInnerClass &#123; &#125; public static void main(String[] args) &#123; OuterClass outerClass = new OuterClass(); //使用外部类对象.new 静态内部类()的语法来创建静态内部类对象 InnerClass innerClass = outerClass.new InnerClass(); //静态内部类可以直接创建 StaticInnerClass staticInnerClass = new StaticInnerClass(); &#125;&#125; 静态内部类不能访问外部类的非静态的变量和方法。 5. 静态导包 在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。 1import static com.xxx.ClassName 6. 初始化顺序 静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。 12345678public static String staticField = "静态变量"; //最先执行static &#123; System.out.println("静态语句块"); //其次&#125;public String field = "实例变量"; //其次&#123; System.out.println("普通语句块"); //其次&#125; 最后才是构造函数的初始化。 123public InitialOrderTest() &#123; System.out.println("构造函数"); //最后执行&#125; 存在继承的情况下，初始化顺序为： 父类（静态变量、静态语句块） 子类（静态变量、静态语句块） 父类（实例变量、普通语句块） 父类（构造函数） 子类（实例变量、普通语句块） 子类（构造函数） 五、 面向对象基本特性1.继承java只支持单继承 2.super关键字super 关键字的功能： 与this不同，this表示当前对象，super表示父类对象 调用父类中声明为 private 的变量。 调用已经覆盖了的方法。 作为方法名表示父类构造方法。 调用隐藏变量和被覆盖的方法1234567891011121314151617181920212223242526272829class People&#123; private String str = "学无止境"; public String getStr() &#123; return str; &#125; public void learn()&#123; System.out.println("人可以靠学习充实自己"); &#125;&#125;class Student extends People&#123; @OverRide public void learn()&#123; super.learn(); // 调用父类的方法 // 通过 getter 方法调用父类隐藏变量 System.out.println("Please remember: " + super.getDesc()); &#125;&#125;public class Demo&#123; public static void main(String[] args) &#123; Student student = new Student(); student.learn(); &#125;&#125;/*运行结果：人可以靠学习充实自己Please remember:学无止境*/ learn() 方法也可以定义在某些祖先类中，Java 具有追溯性，会一直向上找，直到找到该方法为止。 通过 super 调用父类的隐藏变量，必须要在父类中声明 getter 方法，因为声明为 private 的数据成员对子类是不可见的。 声明 : 本文章借鉴于GitHub上，本人只是根据自身学习情况做了一些删改，并添加了一些自己的理解 原文链接 : https://github.com/CyC2018/CS-Notes]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Typora基本用法]]></title>
    <url>%2F2019%2F04%2F12%2FTypora%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Typora编辑器 —-书写即为美学官方网站:https://www.typora.io/ 支持平台 Windows Linux OSX 特点: 完美支持GitHub的Markdown语法; 人性化的书写方式: 表格的书写、挪动; 图片、超链接、网页表格复制; 目录生成; 支持LeTex公式书写; 支持Flowchart,Mermaid等流程图绘制; emoji,高亮,备注,上标,下标等书写; 生成网页,pdf,图片,甚至word,LeTex等格式。 基本的带快捷键的Markdown书写演示Ctrl+0到Ctrl4:普通文本、一级~四级标题; Ctrl+B : 加粗,加粗测试; Ctrl+I : 斜体,斜体测试; Ctrl+U: 下划线,下划线测试； Shift Alt+5: 删除线,删除线测试； 单机一下 ` : 行内代码块; Ctrl+K : 超链接,超链接测试;还支持文章内锚点,请Ctrl点击此处–&gt;第二节； Ctrl+T : 表格,支持拖拽移动、网页端表格复制转换: 标题 数据一 数据二 表格测试 943 baka Ctrl + Shift + Q: 引用 ： 连续按两下Enter可以退出引用 Enter+Enter Shift Ctrl I: 图片: 基本的不带快捷键Markdown书写演示部分功能需要在 文件- 偏好设置 中开启才能使用 `连续输入: 1234567```javapublic class Hello&#123; public static void main(String[] args)&#123; System.out.println(&quot;Hello World!&quot;); &#125;&#125; 无序、有序、任务列表 : JAVA PYTHON CSS 按下Tab可进入下一级列表 HTML 双击Enter退出列表 任务列表可以勾选选项 游戏 女人 代码]]></content>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础语法与数据类型]]></title>
    <url>%2F2019%2F04%2F12%2F%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一、基本类型 byte/8 char/16 short/16 int/32 float/32 long/64 boolean/ 包装类型基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。 12Integer x = 2; // 装箱int y = x; // 拆箱 缓存池new Integer(123) 与 Integer.valueOf(123) 的区别在于： new Integer(123) 每次都会新建一个对象； Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。 123456Integer x = new Integer(123); Integer y = new Integer(123);System.out.println(x == y); // false,x与y为不同对象的引用Integer z = Integer.valueOf(123);Integer k = Integer.valueOf(123);System.out.println(z == k); // true,x与y为缓冲池中同一对象的引用 valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) //判断i是否在-128~127之间 return IntegerCache.cache[i + (-IntegerCache.low)]; //为true返回缓冲池中对象 return new Integer(i); //为false返回一个新对象&#125; 在 Java 8 中，Integer 缓存池的大小默认为 -128~127。 编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。 123Integer m = 123;Integer n = 123;System.out.println(m == n); // true 基本类型对应的缓冲池如下： boolean values true and false all byte values short values between -128 and 127 int values between -128 and 127 char in the range \u0000 to \u007F 在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。 二、StringString在java中表示不可变字符串。 1234567public final class String //String不可继承 implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; private final byte[] value; //value初始化之后不能再引用其他数组,保证String数据不可变 private final byte coder; //指定编码&#125; value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。 String Pool字符串常量池(String Pool)保存所有字符串的字面量，这些字面量在编译时确定。 intern()方法当一个String对象调用intern()方法时,如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。 1234567String s1 = new String(&quot;aaa&quot;);String s2 = new String(&quot;aaa&quot;);System.out.println(&quot;s1 == s2&quot;); false,s1,s2引用堆中不同对象 String s3 = s1.intern(); StringPool中先添加字符串&quot;aaa&quot;,然后s3引用该字符串String s4 = s1.intern(); StringPool已经存在字符串&quot;aaa&quot;,s4直接引用该字符串System.out.println(s3==s4); true,s3,s4引用的是StringPool中同一个字符串&quot;aaa&quot; 字面量形式创建字符串如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中，区别于使用new在堆中创建对象 123String s5 = &quot;bbb&quot;; StringPool新增字符串&quot;bbb&quot;String s6 = &quot;bbb&quot;; 引用StringPool中的&quot;bbb&quot;System.out.println(s5 == s6); // true new String(“abc”)如果StringPool中没有“abc”，这种方式会创建两个字符串对象: “abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象 “abc” 堆中创建一个字符串对象“abc”。 String构造函数源码以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。 1234public String(String original) &#123; this.value = original.value; this.hash = original.hash;&#125; String，StringBuffer，StringBuilder1. 可变性 String 不可变 StringBuffer 和 StringBuilder 可变 2. 线程安全 String 不可变，因此是线程安全的 StringBuilder 线程不安全 StringBuffer 是线程安全的，内部使用 synchronized 进行同步 三、运算隐式类型转换隐式类型转换指的是低精度数据类型转换为转换为高精度数据类型, 不会损失精度，如short(16)–&gt; int(32)，int (32)–&gt; double(64)，数据类型的精度可以理解为在内存中占的字节长度。 byte/8 char/16 short/16 int/32 float/32 long/64 boolean/ 强制类型转换(向下转型)强制类型转换指的是将高精度数据类型强制转换为低精度数据类型，会损失精度，如int(32)–&gt;short(16)，double(64)–&gt;int(32） 一个例子 12double value = 3.1416926;int value1 = (int) value; //double类型强制转换为int型 可想而知，由于double类型为64位，而int类型为32位，用一个int类型变量去接收double类型变量，只能接收到低32位，而高32位的数据便丢失了，也就是损失了精度 switch语句从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。 123456789String s = "a";switch (s) &#123; case "a": System.out.println("aaa"); break; case "b": System.out.println("bbb"); break;&#125; 四、关键字final1.final修饰数据声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。 对于基本类型，final 使数值不变； 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。 1234final int value = 1; value的值将不能修改final Student stu = new Student(); stu将不能引用其他Student对象stu.name="傻狍子"; stu本身数据可以修改 2. final修饰方法 声明方法不能被子类重写。 1public final viod Method()&#123;&#125; //Method方法不能被重写 private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。 3. final修饰类 声明类不允许被继承。 1public final class String&#123;&#125; //String类不可被继承 static1. 静态变量 静态变量：直接属于类，在类初始化时被初始化，通过类名直接访问 实例变量：属于实例，与实例一起初始化与销毁 1234567891011public class Student &#123; private int age; // 实例变量 private static int studentNumber; // 静态变量 public static void main(String[] args) &#123; Student student = new Student(); int age = student.getAge(); int number = Student.studentNumber; //类名直接访问 &#125; ...&#125; 2. 静态方法 静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。 只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。 123456public class Student &#123; private static int studentNumber; public static int getStudentNummber()&#123; //返回学生总数 return studentNumber; &#125;&#125; 3. 静态语句块 静态语句块只在类初始化时运行一次。 123456public class Student &#123; static &#123; System.out.println("加载学生类"); &#125; &#125; 4. 静态内部类 非静态内部类依赖于外部类的实例，而静态内部类不需要。 12345678910111213141516public class OuterClass &#123; class InnerClass &#123; &#125; static class StaticInnerClass &#123; &#125; public static void main(String[] args) &#123; OuterClass outerClass = new OuterClass(); //使用外部类对象.new 静态内部类()的语法来创建静态内部类对象 InnerClass innerClass = outerClass.new InnerClass(); //静态内部类可以直接创建 StaticInnerClass staticInnerClass = new StaticInnerClass(); &#125;&#125; 静态内部类不能访问外部类的非静态的变量和方法。 5. 静态导包 静态导入是 Java 5 的新增特性，用来导入类的静态变量和静态方法。 一般我们导入类都这样写： 1import packageName.className; // 导入某个特定的类 或 1import packageName.*; // 导入包中的所有类 而静态导入可以这样写： 1import static packageName.className.methonName; // 导入某个特定的静态方法 或 1import static packageName.className.*; // 导入类中的所有静态成员 导入后，可以在当前类中直接用方法名调用静态方法，不必再用 className.methodName 来访问。 对于使用频繁的静态变量和静态方法，可以将其静态导入。静态导入的好处是可以简化一些操作，例如输出语句 System.out.println(); 中的 out 就是 System 类的静态变量，可以通过 import static java.lang.System.*; 将其导入，下次直接调用 out.println() 就可以了。 请看下面的代码： 1234567import static java.lang.System.*;import static java.lang.Math.random;public class Demo &#123; public static void main(String[] args) &#123; out.println(&quot;产生的一个随机数：&quot; + random()); &#125;&#125; 运行结果： 产生的一个随机数：0.05800891549018705 6. 初始化顺序 静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。 12345678public static String staticField = "静态变量"; //最先执行static &#123; System.out.println("静态语句块"); //其次&#125;public String field = "实例变量"; //其次&#123; System.out.println("普通语句块"); //其次&#125; 最后才是构造函数的初始化。 123public InitialOrderTest() &#123; System.out.println("构造函数"); //最后执行&#125; 存在继承的情况下，初始化顺序为： 父类（静态变量、静态语句块） 子类（静态变量、静态语句块） 父类（实例变量、普通语句块） 父类（构造函数） 子类（实例变量、普通语句块） 子类（构造函数） 声明 : 本文章借鉴于GitHub上，本人只是根据自身学习情况做了一些删改，并添加了一些自己的理解 原文链接 : https://github.com/CyC2018/CS-Notes]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 齐阳的个人博客主页Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
