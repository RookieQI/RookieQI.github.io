<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YangQi&#39;s blogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://RookieQI.github.io/"/>
  <updated>2019-04-13T12:52:22.388Z</updated>
  <id>https://RookieQI.github.io/</id>
  
  <author>
    <name>齐阳</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>继承与多态</title>
    <link href="https://RookieQI.github.io/2019/04/13/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/"/>
    <id>https://RookieQI.github.io/2019/04/13/继承与多态/</id>
    <published>2019-04-13T03:52:40.000Z</published>
    <updated>2019-04-13T12:52:22.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java继承与多态"><a href="#Java继承与多态" class="headerlink" title="Java继承与多态"></a>Java继承与多态</h1><h2 id="1-继承"><a href="#1-继承" class="headerlink" title="1.继承"></a>1.继承</h2><p>java只支持单继承</p><h3 id="2-super关键字"><a href="#2-super关键字" class="headerlink" title="2.super关键字"></a>2.super关键字</h3><p>super 关键字的功能：</p><ul><li>与this不同，this表示当前对象，super表示父类对象</li><li>调用父类中声明为 private 的变量。</li><li>调用已经覆盖了的方法。</li><li>作为方法名表示父类构造方法。</li></ul><h4 id="调用隐藏变量和被覆盖的方法"><a href="#调用隐藏变量和被覆盖的方法" class="headerlink" title="调用隐藏变量和被覆盖的方法"></a>调用隐藏变量和被覆盖的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String str = <span class="string">"学无止境"</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStr</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> str; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">learn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"人可以靠学习充实自己"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="meta">@OverRide</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">learn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.learn();  <span class="comment">// 调用父类的方法</span></span><br><span class="line">        <span class="comment">// 通过 getter 方法调用父类隐藏变量</span></span><br><span class="line">        System.out.println(<span class="string">"Please remember: "</span> + <span class="keyword">super</span>.getDesc());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.learn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">人可以靠学习充实自己</span></span><br><span class="line"><span class="comment">Please remember:学无止境</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>learn() 方法也可以定义在某些祖先类中，Java 具有追溯性，会一直向上找，直到找到该方法为止。</li><li>通过 super 调用父类的隐藏变量，必须要在父类中声明 getter 方法，因为声明为 private 的数据成员对子类是不可见的。</li></ul><h3 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h3><p><strong>1. 重写（Override）</strong></p><p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</p><p>下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：</p><ul><li><p>重写使用 @Override 注解</p></li><li><p>子类方法访问权限为 public，大于父类的 protected。</p></li><li>子类的返回类型为 ArrayList，是父类返回类型 List 的子类。</li><li>子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List&lt;Integer&gt; <span class="title">func</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">func</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 重载（Overload）</strong></p><p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</p><p>需要特别注意的是，返回值不同，其它都相同不算是重载。</p><h2 id="2-多态"><a href="#2-多态" class="headerlink" title="2.多态"></a>2.多态</h2><h3 id="多态的定义"><a href="#多态的定义" class="headerlink" title="多态的定义"></a>多态的定义</h3><p>多态是指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）</p><h3 id="实现多态的技术"><a href="#实现多态的技术" class="headerlink" title="实现多态的技术"></a>实现多态的技术</h3><p>实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法</p><h3 id="多态的作用"><a href="#多态的作用" class="headerlink" title="多态的作用"></a>多态的作用</h3><p>消除类型之间的耦合关系</p><h3 id="多态存在的必要条件"><a href="#多态存在的必要条件" class="headerlink" title="多态存在的必要条件"></a>多态存在的必要条件</h3><ul><li>要有继承</li><li>要有重写</li><li>父类引用指向子类对象</li></ul><h3 id="Java中多态的实现方式"><a href="#Java中多态的实现方式" class="headerlink" title="Java中多态的实现方式"></a>Java中多态的实现方式</h3><p>实现接口，继承父类方法进行重写，同一个类中进行方法重载</p><h3 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h3><p>作用：java 中的instanceof运算符通过返回一个布尔值来指出，这个对象是否是这个特定类或者是它的子类的一个实例</p><p>该运算符语法: Object object.intanceof(Class classname/Interface interfacename),返回值有以下结果:</p><ul><li>如果对象object是类Classname或者其子类的实例,返回true;</li><li>如果对象object实现了interfacename,返回true;</li><li>其他情况返回false</li></ul><p>一个简单的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Learn</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">learn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Learn</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">learn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"一个人在学习..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">learn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"一个学生在学习..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        People people = <span class="keyword">new</span> Student();<span class="comment">//定义一个实际类型为Student的引用people</span></span><br><span class="line">        <span class="keyword">if</span>(people <span class="keyword">instanceof</span> Object) &#123; System.out.println(<span class="string">"people是一个对象"</span>);&#125;<span class="comment">//true，people是Object的</span></span><br><span class="line">        <span class="keyword">if</span>(people <span class="keyword">instanceof</span> People) &#123; System.out.println(<span class="string">"people是一个人"</span>);&#125;  <span class="comment">//true,people是People的子类</span></span><br><span class="line">        <span class="keyword">if</span>(people <span class="keyword">instanceof</span> Student) &#123;System.out.println(<span class="string">"people是一个学生"</span>);&#125;<span class="comment">//true,people本身是Student类的对象</span></span><br><span class="line">        <span class="keyword">if</span>(people <span class="keyword">instanceof</span> Teacher) &#123;System.out.println(<span class="string">"people是一个教室"</span>);&#125;<span class="comment">//false,people与Teather都是People的子类,属于平行关系</span></span><br><span class="line">        <span class="keyword">if</span>(people <span class="keyword">instanceof</span> Learn)  &#123;System.out.println(<span class="string">"people可以学习"</span>)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">people是一个对象</span><br><span class="line">people是一个人</span><br><span class="line">people是一个学生</span><br><span class="line">people可以学习</span><br></pre></td></tr></table></figure><h3 id="多态对象的类型转换"><a href="#多态对象的类型转换" class="headerlink" title="多态对象的类型转换"></a>多态对象的类型转换</h3><p>假设有以下继承关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A animal is shouting..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"wang!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"miao!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-安全的向上转型"><a href="#1-安全的向上转型" class="headerlink" title="1.安全的向上转型"></a>1.安全的向上转型</h4><p>继承链下级类型的向上级转型，不存在风险，多态的一种体现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    Dog dog = new Dog();</span><br><span class="line">    Animal animal = dog;//发生了隐式的向上转型</span><br><span class="line">    //向上转型会损失一些数据与方法，例如animal将无法访问Dog类的新增方法，只能访问</span><br><span class="line">    Dog类中从Animal类中继承来的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不安全的强制转型"><a href="#不安全的强制转型" class="headerlink" title="不安全的强制转型"></a>不安全的强制转型</h4><p>继承链上次的类型向下级转型，存在风险</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Animal animal = <span class="keyword">new</span> Dog();</span><br><span class="line">    Cat cat = (Cat)animal;<span class="comment">//这里能顺利通过编译,因为编译器会将animal看作Animala类型的引用,但在运行期,animal的实际类型被确定为Dog,将Dog类型强行转换为Cat类型会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用instanceof进行安全的强制类型转换"><a href="#使用instanceof进行安全的强制类型转换" class="headerlink" title="使用instanceof进行安全的强制类型转换"></a>使用instanceof进行安全的强制类型转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Dog();<span class="comment">//代码1</span></span><br><span class="line">        animal.shout();<span class="comment">//根据多态,Animal类型引用animal可以调用Dog类对象的shout()方法</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        但有一点值得注意，由于多态的动态绑定，animal的实际类型是在运行时才确定的，</span></span><br><span class="line"><span class="comment">        也就是说，当我们无法看见代码1时,我们就无法事先知道animal到底指向的是</span></span><br><span class="line"><span class="comment">        Dog对象还是Cat对象,此时若贸然执行animal.shout(),执行的结果必定也是未知的(很简单，如果animal实际对象类型是Dog，则输出"wang!",如果是Cat,则执行"miao!",但我们并不知道实际对象类型)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">/*为了解决上述情况，我们可以在执行animal.shout()语句前，先用instanceof运算符</span></span><br><span class="line"><span class="comment">        判断出animal的类型，再根据相应的类型执行相应的动作*/</span></span><br><span class="line">        <span class="keyword">if</span>(animal <span class="keyword">instanceof</span> Dog)&#123;<span class="comment">//如果animal是Dog类的实例</span></span><br><span class="line">            Dog dog = (Dog)animal;<span class="comment">//将animal强制转型为Dog类型</span></span><br><span class="line">            dog1.shout();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(animal <span class="keyword">instanceof</span> Cat)&#123;<span class="comment">//如果animal是Cat类的实例</span></span><br><span class="line">            Cat cat = (Cat)amimal; <span class="comment">//将animal强制转型为Cat类型</span></span><br><span class="line">            cat.shout();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*执行结果</span></span><br><span class="line"><span class="comment">wang!</span></span><br><span class="line"><span class="comment">wang!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java继承与多态&quot;&gt;&lt;a href=&quot;#Java继承与多态&quot; class=&quot;headerlink&quot; title=&quot;Java继承与多态&quot;&gt;&lt;/a&gt;Java继承与多态&lt;/h1&gt;&lt;h2 id=&quot;1-继承&quot;&gt;&lt;a href=&quot;#1-继承&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="JAVA" scheme="https://RookieQI.github.io/categories/JAVA/"/>
    
    
      <category term="JavaSE" scheme="https://RookieQI.github.io/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>Typora基本用法</title>
    <link href="https://RookieQI.github.io/2019/04/12/Typora%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <id>https://RookieQI.github.io/2019/04/12/Typora基本用法/</id>
    <published>2019-04-12T13:56:59.000Z</published>
    <updated>2019-04-13T12:52:26.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Typora编辑器-—-书写即为美学"><a href="#Typora编辑器-—-书写即为美学" class="headerlink" title="Typora编辑器 —-书写即为美学"></a>Typora编辑器 —-书写即为美学</h1><p>官方网站:<a href>https://www.typora.io/</a></p><p>支持平台</p><ul><li>Windows</li><li>Linux</li><li>OSX</li></ul><p>特点:</p><ul><li>完美支持GitHub的Markdown语法;</li><li>人性化的书写方式:<ul><li>表格的书写、挪动;</li><li>图片、超链接、网页表格复制;</li><li>目录生成;</li></ul></li><li>支持LeTex公式书写;</li><li>支持Flowchart,Mermaid等流程图绘制;</li><li>emoji,高亮,备注,上标,下标等书写;</li><li>生成网页,pdf,图片,甚至word,LeTex等格式。</li></ul><h2 id="基本的带快捷键的Markdown书写演示"><a href="#基本的带快捷键的Markdown书写演示" class="headerlink" title="基本的带快捷键的Markdown书写演示"></a>基本的带快捷键的Markdown书写演示</h2><p><code>Ctrl+0</code>到<code>Ctrl4</code>:普通文本、一级~四级标题;</p><p><code>Ctrl+B</code> : 加粗,<strong>加粗测试</strong>;</p><p><code>Ctrl+I</code> : 斜体,<em>斜体测试</em>;</p><p><code>Ctrl+U</code>: 下划线,<u>下划线测试</u>；</p><p><code>Shift Alt+5</code>:  删除线,<del>删除线测试</del>；</p><p>单机一下  `  : 行内代码块;</p><p><code>Ctrl+K</code> : 超链接,<a href>超链接测试</a>;还支持文章内锚点,请<code>Ctrl</code>点击此处–&gt;<a href>第二节</a>；</p><p><code>Ctrl+T</code> :  表格,支持拖拽移动、网页端表格复制转换:</p><table><thead><tr><th style="text-align:center">标题</th><th style="text-align:center">数据一</th><th style="text-align:center">数据二</th></tr></thead><tbody><tr><td style="text-align:center">表格测试</td><td style="text-align:center">943</td><td style="text-align:center">baka</td></tr></tbody></table><p><code>Ctrl + Shift + Q</code>: 引用 ：</p><blockquote><p>连续按两下Enter可以退出引用</p><p>Enter+Enter</p></blockquote><p><code>Shift Ctrl I</code>: 图片:</p><p><img src="E:\ASUS\Documents\3dbe04558b5d31c54a9f559553ef8d579e4a28325cfc017ed6be7fbb59a4e59c.jpg" alt="有道"></p><h2 id="基本的不带快捷键Markdown书写演示"><a href="#基本的不带快捷键Markdown书写演示" class="headerlink" title="基本的不带快捷键Markdown书写演示"></a>基本的不带快捷键Markdown书写演示</h2><p><strong>部分功能需要在 <code>文件</code>- <code>偏好设置</code> 中开启才能使用 </strong></p><p>`连续输入<figure class="highlight plain"><figcaption><span>: </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class Hello&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>无序、有序、任务列表</strong> :</p><ul><li><p>JAVA</p></li><li><p>PYTHON</p><ul><li>CSS   <code>按下Tab可进入下一级列表</code></li><li>HTML</li></ul><p><code>双击Enter退出列表</code></p></li></ul><p>  <code>任务列表可以勾选选项</code></p><ul><li style="list-style: none"><input type="checkbox"> 游戏</li><li style="list-style: none"><input type="checkbox"> 女人</li><li style="list-style: none"><input type="checkbox" checked> 代码</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Typora编辑器-—-书写即为美学&quot;&gt;&lt;a href=&quot;#Typora编辑器-—-书写即为美学&quot; class=&quot;headerlink&quot; title=&quot;Typora编辑器 —-书写即为美学&quot;&gt;&lt;/a&gt;Typora编辑器 —-书写即为美学&lt;/h1&gt;&lt;p&gt;官方网站:&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>博客的起点</title>
    <link href="https://RookieQI.github.io/2019/04/12/%E5%8D%9A%E5%AE%A2%E4%BB%8B%E7%BB%8D/"/>
    <id>https://RookieQI.github.io/2019/04/12/博客介绍/</id>
    <published>2019-04-12T13:56:59.000Z</published>
    <updated>2019-04-13T12:47:18.330Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作者的一些话"><a href="#作者的一些话" class="headerlink" title="#作者的一些话"></a>#作者的一些话</h2><h4 id="您好-欢迎您浏览本博客-我是本博客的作者91MrQi，如果您也是一位编程的爱好者-我想我们可以做朋友…"><a href="#您好-欢迎您浏览本博客-我是本博客的作者91MrQi，如果您也是一位编程的爱好者-我想我们可以做朋友…" class="headerlink" title="您好!欢迎您浏览本博客,我是本博客的作者91MrQi，如果您也是一位编程的爱好者,我想我们可以做朋友…"></a>您好!欢迎您浏览本博客,我是本博客的作者91MrQi，如果您也是一位编程的爱好者,我想我们可以做朋友…</h4><h2 id="以下是本博客所有文章的目录，您可以点击链接进入您想要浏览的文章"><a href="#以下是本博客所有文章的目录，您可以点击链接进入您想要浏览的文章" class="headerlink" title="以下是本博客所有文章的目录，您可以点击链接进入您想要浏览的文章"></a>以下是本博客所有文章的目录，您可以点击链接进入您想要浏览的文章</h2><h3 id="JAVA-SE部分"><a href="#JAVA-SE部分" class="headerlink" title="JAVA SE部分"></a>JAVA SE部分</h3><ul><li>JAVA 概述</li><li><a href="/2019/04/12/Java基础语法与数据类型/#more">JAVA 基础语法与数据类型</a></li><li><a href="/2019/04/13/继承与多态/#more">JAVA 继承与多态</a></li><li>JAVA 容器</li><li>JAVA 异常</li><li>JAVA I/O</li><li>JAVA 泛型</li><li>JAVA 并发</li><li>JAVA 虚拟机</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;作者的一些话&quot;&gt;&lt;a href=&quot;#作者的一些话&quot; class=&quot;headerlink&quot; title=&quot;#作者的一些话&quot;&gt;&lt;/a&gt;#作者的一些话&lt;/h2&gt;&lt;h4 id=&quot;您好-欢迎您浏览本博客-我是本博客的作者91MrQi，如果您也是一位编程的爱好者-我想我们可以
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVA基础语法与数据类型</title>
    <link href="https://RookieQI.github.io/2019/04/12/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://RookieQI.github.io/2019/04/12/Java基础语法与数据类型/</id>
    <published>2019-04-12T13:56:59.000Z</published>
    <updated>2019-04-13T12:52:31.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、基本类型"><a href="#一、基本类型" class="headerlink" title="一、基本类型"></a>一、基本类型</h2><table><thead><tr><th>byte/8</th><th>char/16</th></tr></thead><tbody><tr><td>short/16</td><td>int/32</td></tr><tr><td>float/32</td><td>long/64</td></tr><tr><td>boolean/</td></tr></tbody></table><h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer x = 2;     // 装箱</span><br><span class="line">int y = x;         // 拆箱</span><br></pre></td></tr></table></figure><h3 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h3><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p><ul><li>new Integer(123) 每次都会新建一个对象；</li><li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false,x与y为不同对象的引用</span></span><br><span class="line">Integer z = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">Integer k = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true,x与y为缓冲池中同一对象的引用</span></span><br></pre></td></tr></table></figure><p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) <span class="comment">//判断i是否在-128~127之间</span></span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)]; <span class="comment">//为true返回缓冲池中对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i); <span class="comment">//为false返回一个新对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p><p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer m = <span class="number">123</span>;</span><br><span class="line">Integer n = <span class="number">123</span>;</span><br><span class="line">System.out.println(m == n); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>基本类型对应的缓冲池如下：</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul><p>在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</p><h2 id="二、String"><a href="#二、String" class="headerlink" title="二、String"></a>二、String</h2><p>String在java中表示不可变字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span>//<span class="title">String</span>不可继承</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;<span class="comment">//value初始化之后不能再引用其他数组,保证String数据不可变</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> coder;<span class="comment">//指定编码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p><h3 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h3><p>字符串常量池(String Pool)保存所有字符串的字面量，这些字面量在编译时确定。</p><h4 id="intern-方法"><a href="#intern-方法" class="headerlink" title="intern()方法"></a>intern()方法</h4><p>当一个String对象调用intern()方法时,如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">System.out.println(<span class="string">"s1 == s2"</span>); <span class="keyword">false</span>,s1,s2引用堆中不同对象</span><br><span class="line">String s3 = s1.intern(); StringPool中先添加字符串<span class="string">"aaa"</span>,然后s3引用该字符串</span><br><span class="line">String s4 = s1.intern(); StringPool已经存在字符</span><br><span class="line">串<span class="string">"aaa"</span>,s4直接引用该字符串</span><br><span class="line">System.out.println(s3==s4); <span class="keyword">true</span>,s3,s4引用的是StringPool中同一个字符串<span class="string">"aaa"</span></span><br></pre></td></tr></table></figure><h4 id="字面量形式创建字符串"><a href="#字面量形式创建字符串" class="headerlink" title="字面量形式创建字符串"></a>字面量形式创建字符串</h4><p>如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中，区别于使用new在堆中创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s5 = <span class="string">"bbb"</span>;StringPool新增字符串<span class="string">"bbb"</span></span><br><span class="line">String s6 = <span class="string">"bbb"</span>;引用StringPool中的<span class="string">"bbb"</span></span><br><span class="line">System.out.println(s5 == s6);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="new-String-“abc”"><a href="#new-String-“abc”" class="headerlink" title="new String(“abc”)"></a>new String(“abc”)</h4><p>如果StringPool中没有“abc”，这种方式会创建两个字符串对象:</p><ul><li>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象 “abc”</li><li>堆中创建一个字符串对象“abc”。</li></ul><h4 id="String构造函数源码"><a href="#String构造函数源码" class="headerlink" title="String构造函数源码"></a>String构造函数源码</h4><p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="String，StringBuffer，StringBuilder"><a href="#String，StringBuffer，StringBuilder" class="headerlink" title="String，StringBuffer，StringBuilder"></a>String，StringBuffer，StringBuilder</h4><p><strong>1. 可变性</strong></p><ul><li>String 不可变</li><li>StringBuffer 和 StringBuilder 可变</li></ul><p><strong>2. 线程安全</strong></p><ul><li>String 不可变，因此是线程安全的</li><li>StringBuilder 线程不安全</li><li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li></ul><h2 id="三、运算"><a href="#三、运算" class="headerlink" title="三、运算"></a>三、运算</h2><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>隐式类型转换指的是低精度数据类型转换为转换为高精度数据类型,</p><p>不会损失精度，如short(16)–&gt; int(32)，int (32)–&gt; double(64)，数据类型的精度可以理解为在内存中占的字节长度。</p><table><thead><tr><th>byte/8</th><th>char/16</th></tr></thead><tbody><tr><td>short/16</td><td>int/32</td></tr><tr><td>float/32</td><td>long/64</td></tr><tr><td>boolean/</td></tr></tbody></table><h3 id="强制类型转换-向下转型"><a href="#强制类型转换-向下转型" class="headerlink" title="强制类型转换(向下转型)"></a>强制类型转换(向下转型)</h3><p>强制类型转换指的是将高精度数据类型强制转换为低精度数据类型，会损失精度，如int(32)–&gt;short(16)，double(64)–&gt;int(32）</p><ul><li>一个例子</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double value = 3.1416926;</span><br><span class="line">int value1 = (int) value; //double类型强制转换为int型</span><br></pre></td></tr></table></figure><p>可想而知，由于double类型为64位，而int类型为32位，用一个int类型变量去接收double类型变量，只能接收到低32位，而高32位的数据便丢失了，也就是损失了精度</p><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"a"</span>;</span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"a"</span>:</span><br><span class="line">        System.out.println(<span class="string">"aaa"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"b"</span>:</span><br><span class="line">        System.out.println(<span class="string">"bbb"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、关键字"><a href="#四、关键字" class="headerlink" title="四、关键字"></a>四、关键字</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><h4 id="1-final修饰数据"><a href="#1-final修饰数据" class="headerlink" title="1.final修饰数据"></a>1.final修饰数据</h4><p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p><ul><li>对于基本类型，final 使数值不变；</li><li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">1</span>; value的值将不能修改</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Student stu = <span class="keyword">new</span> Student();stu将不能引用其他Student对象</span><br><span class="line">stu.name=<span class="string">"傻狍子"</span>;  stu本身数据可以修改</span><br></pre></td></tr></table></figure><p><strong>2. final修饰方法</strong></p><p>声明方法不能被子类重写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> viod <span class="title">Method</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//Method方法不能被重写</span></span><br></pre></td></tr></table></figure><p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p><p><strong>3. final修饰类</strong></p><p>声明类不允许被继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span>&#123;&#125;<span class="comment">//String类不可被继承</span></span><br></pre></td></tr></table></figure><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><strong>1. 静态变量</strong></p><ul><li>静态变量：直接属于类，在类初始化时被初始化，通过类名直接访问</li><li>实例变量：属于实例，与实例一起初始化与销毁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;         <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> studentNumber;  <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="keyword">int</span> age = student.getAge();</span><br><span class="line">        <span class="keyword">int</span> number =  Student.studentNumber; <span class="comment">//类名直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 静态方法</strong></p><p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p><p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> studentNumber;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getStudentNummber</span><span class="params">()</span></span>&#123;<span class="comment">//返回学生总数</span></span><br><span class="line">        <span class="keyword">return</span> studentNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 静态语句块</strong></p><p>静态语句块只在类初始化时运行一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"加载学生类"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 静态内部类</strong></p><p>非静态内部类依赖于外部类的实例，而静态内部类不需要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OuterClass outerClass = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        <span class="comment">//使用外部类对象.new 静态内部类()的语法来创建静态内部类对象</span></span><br><span class="line">        InnerClass innerClass = outerClass.new InnerClass(); </span><br><span class="line">        <span class="comment">//静态内部类可以直接创建</span></span><br><span class="line">        StaticInnerClass staticInnerClass = <span class="keyword">new</span> StaticInnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类不能访问外部类的非静态的变量和方法。</p><p><strong>5. 静态导包</strong></p><p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.xxx.ClassName</span><br></pre></td></tr></table></figure><p><strong>6. 初始化顺序</strong></p><p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String staticField = <span class="string">"静态变量"</span>;<span class="comment">//最先执行</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"静态语句块"</span>);<span class="comment">//其次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String field = <span class="string">"实例变量"</span>;<span class="comment">//其次</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"普通语句块"</span>);<span class="comment">//其次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后才是构造函数的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InitialOrderTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"构造函数"</span>);<span class="comment">//最后执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在继承的情况下，初始化顺序为：</p><ul><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ul><h2 id="五、-面向对象基本特性"><a href="#五、-面向对象基本特性" class="headerlink" title="五、 面向对象基本特性"></a>五、 面向对象基本特性</h2><h3 id="1-继承"><a href="#1-继承" class="headerlink" title="1.继承"></a>1.继承</h3><p>java只支持单继承</p><h3 id="2-super关键字"><a href="#2-super关键字" class="headerlink" title="2.super关键字"></a>2.super关键字</h3><p>super 关键字的功能：</p><ul><li><p>与this不同，this表示当前对象，super表示父类对象</p></li><li><p>调用父类中声明为 private 的变量。</p></li><li>调用已经覆盖了的方法。</li><li>作为方法名表示父类构造方法。</li></ul><h4 id="调用隐藏变量和被覆盖的方法"><a href="#调用隐藏变量和被覆盖的方法" class="headerlink" title="调用隐藏变量和被覆盖的方法"></a>调用隐藏变量和被覆盖的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String str = <span class="string">"学无止境"</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStr</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> str; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">learn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"人可以靠学习充实自己"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="meta">@OverRide</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">learn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.learn();  <span class="comment">// 调用父类的方法</span></span><br><span class="line">        <span class="comment">// 通过 getter 方法调用父类隐藏变量</span></span><br><span class="line">        System.out.println(<span class="string">"Please remember: "</span> + <span class="keyword">super</span>.getDesc());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.learn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">人可以靠学习充实自己</span></span><br><span class="line"><span class="comment">Please remember:学无止境</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><p>learn() 方法也可以定义在某些祖先类中，Java 具有追溯性，会一直向上找，直到找到该方法为止。</p></li><li><p>通过 super 调用父类的隐藏变量，必须要在父类中声明 getter 方法，因为声明为 private 的数据成员对子类是不可见的。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、基本类型&quot;&gt;&lt;a href=&quot;#一、基本类型&quot; class=&quot;headerlink&quot; title=&quot;一、基本类型&quot;&gt;&lt;/a&gt;一、基本类型&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;byte/8&lt;/th&gt;
&lt;th&gt;char/16&lt;/th&gt;
&lt;/t
      
    
    </summary>
    
      <category term="JAVA" scheme="https://RookieQI.github.io/categories/JAVA/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://RookieQI.github.io/2019/04/11/hello-world/"/>
    <id>https://RookieQI.github.io/2019/04/11/hello-world/</id>
    <published>2019-04-11T12:59:19.885Z</published>
    <updated>2019-04-13T10:10:39.792Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="齐阳的个人博客主页"><a href="#齐阳的个人博客主页" class="headerlink" title="齐阳的个人博客主页"></a>齐阳的个人博客主页</h2><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
