<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YangQi&#39;s blogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://RookieQI.github.io/"/>
  <updated>2019-04-15T14:22:32.451Z</updated>
  <id>https://RookieQI.github.io/</id>
  
  <author>
    <name>齐阳</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java完整学习路线</title>
    <link href="https://RookieQI.github.io/2019/04/15/Java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <id>https://RookieQI.github.io/2019/04/15/Java学习路线/</id>
    <published>2019-04-15T13:52:43.000Z</published>
    <updated>2019-04-15T14:22:32.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java完整学习路线"><a href="#Java完整学习路线" class="headerlink" title="Java完整学习路线"></a>Java完整学习路线</h1><h2 id="JavaSE-第一阶段"><a href="#JavaSE-第一阶段" class="headerlink" title="JavaSE(第一阶段)"></a>JavaSE(第一阶段)</h2><table><thead><tr><th style="text-align:left">技术名称</th><th style="text-align:left">技术内容</th></tr></thead><tbody><tr><td style="text-align:left">Java基础语法</td><td style="text-align:left">Java语法格式，常量和变量，变量的作用域，方法和方法的重载，运算符，程序流程控制，数组和操作数组的类，对数组循环遍历以及针对数组的常用查找、排序算法原理，最后使用Java程序进行功能实现。</td></tr><tr><td style="text-align:left">面向对象编程</td><td style="text-align:left">理解对象的本质，以及面向对象，类与对象之间的关系，如何用面向对象的思想分析和解决显示生活中的问题，并java程序的手段编写出来。如何设计类，设计类的基本原则，类的实例化过程，类元素：构造函数、this关键字、方法和方法的参数传递过程、static关键字、内部类，Java的垃圾对象回收机制。对象的三大特性：封装、继承和多态。子类对象的实例化过程、方法的重写和重载、final关键字、抽象类、接口、继承的优点和缺点。 对象的多态性：子类和父类之间的转换、父类纸箱子类的引用、抽象类和接口在多态中的应用、多态优点。常用设计模式如单利、模版等模式。什么是异常 异常的捕捉和抛出 异常捕捉的原则 finally的使用，package的应用 import关键字。</td></tr><tr><td style="text-align:left">多线程应用</td><td style="text-align:left">多线程的概念，如何在程序中创建多线程(Thread、Runnable)，线程安全问题，线程的同步，线程之间的通讯、死锁问题的剖析。</td></tr><tr><td style="text-align:left">javaAPI详解</td><td style="text-align:left">JavaAPI介绍、String和StringBuffer、各种基本数据类型包装类，System和Runtime类，Date和DateFomat类等。常用的集合类使用如下：Java Collections Framework：Collection、Set、List、ArrayList、Vector、LinkedList、Hashset、TreeSet、Map、HashMap、TreeMap、Iterator、Enumeration等常用集合类API。</td></tr><tr><td style="text-align:left">IO技术</td><td style="text-align:left">什么是IO，File及相关类，字节流InputStream和OutputStream，字符流Reader和Writer，以及相应缓冲流和管道流，字节和字符的转化流，包装流，以及常用包装类使用，分析java的IO性能。</td></tr><tr><td style="text-align:left">网络编程</td><td style="text-align:left">Java网络编程，网络通信底层协议TCP/UDP/IP，Socket编程。网络通信常用应用层协议简介：HTTP、FTP等，以及WEB服务器的工作原理。</td></tr><tr><td style="text-align:left">java高级特性</td><td style="text-align:left">递归程序，Java的高级特性：反射、代理和泛型、枚举、Java正则表达式API详解及其应用。</td></tr></tbody></table><h2 id="数据库技术-第二阶段"><a href="#数据库技术-第二阶段" class="headerlink" title="(数据库技术) 第二阶段"></a>(数据库技术) 第二阶段</h2><table><thead><tr><th style="text-align:left">技术名称</th><th style="text-align:left">技术内容</th></tr></thead><tbody><tr><td style="text-align:left">Oracle 基础管理</td><td style="text-align:left">Oracle背景简介，数据库的安装，数据库的用户名和密码，客户端登录数据库服务SQLPLUS，数据库基本概。</td></tr><tr><td style="text-align:left">SQL语句</td><td style="text-align:left">数据库的创建，表的创建，修改，删除，查询，索引的创建，主从表的建立，数据控制授权和回收，事务控制，查询语句以及运算符的详解，sql中的函数使用。</td></tr><tr><td style="text-align:left">多表连接和子查询</td><td style="text-align:left">等值和非等值连接，外连接，自连接；交叉连接，自然连接，using子句连接，完全外连接和左右外连接，子查询使用以及注意事项。</td></tr><tr><td style="text-align:left">触发器、存储过程</td><td style="text-align:left">触发器和存储过程使用场合， 通过实例进行详解。</td></tr><tr><td style="text-align:left">数据库设计优化</td><td style="text-align:left">WHERE子句中的连接顺序，选择最有效率的表名顺序，SELECT子句中避免使用 ‘ * ‘ 计算记录条数等等。</td></tr><tr><td style="text-align:left">数据备份与移植</td><td style="text-align:left">移植技巧，备份方案；导入导出等。</td></tr></tbody></table><h2 id="JDBC技术-第三阶段"><a href="#JDBC技术-第三阶段" class="headerlink" title="JDBC技术(第三阶段)"></a>JDBC技术(第三阶段)</h2><table><thead><tr><th style="text-align:left">技术名称</th><th style="text-align:left">技术内容</th></tr></thead><tbody><tr><td style="text-align:left">JDBC基础</td><td style="text-align:left">JDBC Connection、Statement、PreparedStatement、CallableStatement、ResultSet等不同类的使用。</td></tr><tr><td style="text-align:left">连接池技术</td><td style="text-align:left">了解连接池的概念，掌握连接池的建立、治理、关闭和配置。</td></tr><tr><td style="text-align:left">ORM与DAO封装</td><td style="text-align:left">对象关系映射思想，jdbc的dao封装，实现自己的jdbc。</td></tr></tbody></table><h2 id="Web基础技术-第四阶段"><a href="#Web基础技术-第四阶段" class="headerlink" title="Web基础技术(第四阶段)"></a>Web基础技术(第四阶段)</h2><table><thead><tr><th style="text-align:left">技术名称</th><th style="text-align:left">技术内容</th></tr></thead><tbody><tr><td style="text-align:left">Xml技术</td><td style="text-align:left">使用jdom和dom4j来对xml文档的解析和生成操作，xml 的作用和使用场合。</td></tr><tr><td style="text-align:left">html/css</td><td style="text-align:left">Java掌握基本的html标签的格式和使用，css层叠样式表对div的定义，实现对网站布局的基本实现。</td></tr><tr><td style="text-align:left">Javascript</td><td style="text-align:left">了解javascript的基本语法以及相关函数的使用，并结合html页面实现流程控制和页面效果展示。什么是异常 异常的捕捉和抛出 异常捕捉的原则 finally的使用，package的应用 import关键字。</td></tr><tr><td style="text-align:left">jsp/servlet</td><td style="text-align:left">Servlet和SP 技术、上传下载、 Tomcat 服务器技术、servlet 过滤器和监听器。</td></tr><tr><td style="text-align:left">jstl和EL</td><td style="text-align:left">JSTL核心标签库、函数标签库、格式化标签库、自定义标签技术、EL表达式在jsp页面的使用。</td></tr><tr><td style="text-align:left">ajax及框架技术</td><td style="text-align:left">了解和属性原生态的ajax的使用，ajax使用的场合，使用ajax的好处，ajax框架jquery渲染页面效果和相关的强大的第三方类库，dwr如何和后台服务进行数据传输，以及页面逻辑控制等。</td></tr><tr><td style="text-align:left">JSON高级应用</td><td style="text-align:left">Java使用json支持的方式对字符串进行封装和解析，实现页面和java后台服务的数据通信。</td></tr><tr><td style="text-align:left">Fckeditor编辑器</td><td style="text-align:left">FCKEditor在线编辑器技术、配置、处理图片和文件上传。</td></tr><tr><td style="text-align:left">javaMail技术</td><td style="text-align:left">了解域名解析与MX记录、电子邮件工作原理、邮件传输协议：SMTP、POP3、IMAP、邮件组织结构：RFC822邮件格式、MIME协议、邮件编码、复合邮件结构分析、JavaMail API及其体系结构、编程创建邮件内容：简单邮件内容、包含内嵌图片的复杂邮件、包含内嵌图片和附件的复杂邮件。</td></tr><tr><td style="text-align:left">JfreeChart报表</td><td style="text-align:left">统计报表；图表处理。</td></tr><tr><td style="text-align:left">BBS项目实战</td><td style="text-align:left">采用Jquery+dwr+jsp+servlet+Fckeditor+JfreeChart+tomcat+jdbc(oracle) 完成BBS项目的实战。</td></tr></tbody></table><h2 id="（web主流框架技术-项目实战-）第五阶段"><a href="#（web主流框架技术-项目实战-）第五阶段" class="headerlink" title="（web主流框架技术(项目实战)）第五阶段"></a>（web主流框架技术(项目实战)）第五阶段</h2><table><thead><tr><th style="text-align:left">技术名称</th><th style="text-align:left">技术内容</th></tr></thead><tbody><tr><td style="text-align:left">struts2.x</td><td style="text-align:left">struts2框架的工作原理和架构分析，struts-default.xml与default.properties文件的作用，struts。Xml中引入多个配置文件。OGNL表达式、Struts2 UI和非UI标签、输入校验、使用通配符定义action、动态方法调用、多文件上传、自定义类型转换器、为Action的属性注入值、自定义拦截器、异常处理、使用struts2实现的CRUD操作的案例。</td></tr><tr><td style="text-align:left">hibernate3.x</td><td style="text-align:left">Hibernate应用开发基础； ORM基础理论； 关系映射技术； 性能调优技术； 性能优化 一级缓存 二级缓存 查询缓存 事务与并发 悲观锁、乐观锁。</td></tr><tr><td style="text-align:left">spring3.x</td><td style="text-align:left">Spring IoC技术； Spring AOP技术； Spring 声明事务管理； Spring 常用功能说明，spring3.0的新特性， Spring整合struts2和hibernate3的运用。</td></tr><tr><td style="text-align:left">Log4j和Junit</td><td style="text-align:left">Logging API； JUnit单元测试技术； 压力测试技术：badboy 进行测试计划跟踪获取以及JMeter压力测试。</td></tr><tr><td style="text-align:left">在线支付技术</td><td style="text-align:left">完成支付宝的支付接口的在线支付功能。</td></tr><tr><td style="text-align:left">电子商务网实战</td><td style="text-align:left">采用spring3+hibernate3+struts2+jquery+dwr+FckEditor+tomcat 完成电子商务网站实战开发。</td></tr></tbody></table><h2 id="web高级进阶-项目实战-第六阶段"><a href="#web高级进阶-项目实战-第六阶段" class="headerlink" title="web高级进阶(项目实战)第六阶段"></a>web高级进阶(项目实战)第六阶段</h2><table><thead><tr><th style="text-align:left">技术名称</th><th style="text-align:left">技术内容</th></tr></thead><tbody><tr><td style="text-align:left">openJpa技术</td><td style="text-align:left">JPA介绍及开发环境搭建、单表实体映射、一对多/多对一、一对一、多对多关联、实体继承、复合主键、JPQL语句、EntityManager API、事务管理，了解一下jpa2.0的新特性以及应用。</td></tr><tr><td style="text-align:left">lucene搜索引擎</td><td style="text-align:left">了解全文搜索原理、全文搜索引擎、什么是OSEM、OSEM框架Compass、基于使用Lucene使用Compass实现全文增量型索引创建和搜索、探索Lucene 3.0以及API。</td></tr><tr><td style="text-align:left">电子商务网重构</td><td style="text-align:left">此项目采用了Lucene+compass+openJpa+上一版电子商务网站的技术进行重构。</td></tr><tr><td style="text-align:left">Excel/PDF文档处理技术</td><td style="text-align:left">ava对excel和pdf文档分别利用poi和itext来进行解析和生成。此技术在企业级系统的报表中经常使用。</td></tr><tr><td style="text-align:left">OA工作流技术JBPM</td><td style="text-align:left">工作流是什么、JBPM介绍、JBPM的主要用法、各类节点的用法、任务各种分派方式、JBPM的整体架构原理、工作流定义模型分析、运行期工作流实例模型分析、数据库表模型分析、流程定义管理、流程实例监控、对JBPM的相关接口进行封装，构建自己的工作流应用平台等。</td></tr><tr><td style="text-align:left">WebService技术</td><td style="text-align:left">WebService技术原理、WebService技术的应用、Soap服务的创建与管理、WSDL描述文档规范、UDDI 注册中心运行原理;使用Axis和Xfire创建WEB服务、Webservice客户端的编写、使用TCPMonitor监听SOAP协议、异构平台的整合。</td></tr><tr><td style="text-align:left">Linux技术</td><td style="text-align:left">Linux 系统安装，卸载、linux 使用的核心思想、linux下的用户管理，文件管理,系统管理、程序的安装，使用，卸载。linux下作为server的基本应用：web服务器，j2ee服务器，ftp服务器的安装和项目的部署。</td></tr><tr><td style="text-align:left">CRM项目实战</td><td style="text-align:left">此项目能了解和熟悉客户关系管理的基本流程以及功能的实现，采用上面几个阶段学到的主流框架实现，同时加入了JBPM的技术。</td></tr></tbody></table><h2 id="大型高并发网站优化方案-项目实战-第七阶段"><a href="#大型高并发网站优化方案-项目实战-第七阶段" class="headerlink" title="大型高并发网站优化方案(项目实战)(第七阶段)"></a>大型高并发网站优化方案(项目实战)(第七阶段)</h2><table><thead><tr><th style="text-align:left">技术名称</th><th style="text-align:left">技术内容</th></tr></thead><tbody><tr><td style="text-align:left">如何构建一个高性能网站详解</td><td style="text-align:left">什么样的网站需要高性能，高性能的指标体系，构建高性能网站需要做哪些工作，注意哪些细节。</td></tr><tr><td style="text-align:left">SSI技术</td><td style="text-align:left">什么是SSI，使用他有什么好处，什么样的系统才使用SSI，SSI技术详解和使用，应用到项目中。</td></tr><tr><td style="text-align:left">生成静态页技术</td><td style="text-align:left">什么是静态页，为什么需要静态页以及带来的好处，生成静态页的模版技术Velocity和Freemark，生成静态页的访问规则等。</td></tr><tr><td style="text-align:left">缓存技术</td><td style="text-align:left">为什么使用缓存技术，oscache缓存技术的介绍和使用，memcached缓存技术的介绍和使用、两者缓存技术的比较和如何去使用。</td></tr><tr><td style="text-align:left">经典web服务器</td><td style="text-align:left">什么是web服务器，什么是javaweb服务器，他们存在什么关系，当前技术主流中常用的web服务器有哪些， web服务器apache和nginx的应用。</td></tr><tr><td style="text-align:left">nginx架构实战</td><td style="text-align:left">什么是反向代理，负载均衡以及集群，在nginx中如何实现这些高性能的系统架构。</td></tr></tbody></table><p><strong>清楚了完整的学习路线，你就可以正式踏上你的光头之旅啦!(滑稽~)</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java完整学习路线&quot;&gt;&lt;a href=&quot;#Java完整学习路线&quot; class=&quot;headerlink&quot; title=&quot;Java完整学习路线&quot;&gt;&lt;/a&gt;Java完整学习路线&lt;/h1&gt;&lt;h2 id=&quot;JavaSE-第一阶段&quot;&gt;&lt;a href=&quot;#JavaSE-第一阶
      
    
    </summary>
    
    
      <category term="Java" scheme="https://RookieQI.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://RookieQI.github.io/2019/04/15/Java%E5%BC%82%E5%B8%B8/"/>
    <id>https://RookieQI.github.io/2019/04/15/Java异常/</id>
    <published>2019-04-15T13:28:41.204Z</published>
    <updated>2019-04-15T13:28:41.205Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java容器</title>
    <link href="https://RookieQI.github.io/2019/04/13/Java%E5%AE%B9%E5%99%A8/"/>
    <id>https://RookieQI.github.io/2019/04/13/Java容器/</id>
    <published>2019-04-13T15:58:59.000Z</published>
    <updated>2019-04-15T13:13:25.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java容器"><a href="#Java容器" class="headerlink" title="Java容器"></a>Java容器</h1><h2 id="1-概览"><a href="#1-概览" class="headerlink" title="1.概览"></a>1.概览</h2><p>Java容器只要包括collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</p><h3 id="Collection框架图"><a href="#Collection框架图" class="headerlink" title="Collection框架图"></a>Collection框架图</h3><p><img src="/2019/04/13/Java容器/col.png" alt></p><table><thead><tr><th style="text-align:left">Collection种类</th><th>特点</th></tr></thead><tbody><tr><td style="text-align:left">TreeSet</td><td>基于红黑树实现，支持有序性操作，可以根据一个范围查找元素。查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</td></tr><tr><td style="text-align:left">HashSet</td><td>基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</td></tr><tr><td style="text-align:left">LinkedHashSet</td><td>具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</td></tr><tr><td style="text-align:left">ArrayList(常用)</td><td>基于动态数组实现，支持随机访问，线程不安全</td></tr><tr><td style="text-align:left">Vector</td><td>和 ArrayList 类似，但它是线程安全的</td></tr><tr><td style="text-align:left">LinkedList</td><td>基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列</td></tr><tr><td style="text-align:left">LinkedList：</td><td>可以用它来实现双向队列</td></tr><tr><td style="text-align:left">PriorityQueue：</td><td>基于堆结构实现，可以用它来实现优先队列</td></tr></tbody></table><h3 id="Map框架图"><a href="#Map框架图" class="headerlink" title="Map框架图"></a>Map框架图</h3><p><img src="/2019/04/13/Java容器/Map.png" alt></p><table><thead><tr><th>Map种类</th><th>特点</th></tr></thead><tbody><tr><td>TreeMap</td><td>基于红黑树实现</td></tr><tr><td>HashMap</td><td>基于哈希表实现</td></tr><tr><td>LinkedHashMap</td><td>使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序</td></tr><tr><td>HashTable</td><td>不支持使用，可以用ConcurrentHashMap替代</td></tr></tbody></table><h2 id="容器中的设计模式"><a href="#容器中的设计模式" class="headerlink" title="容器中的设计模式"></a>容器中的设计模式</h2><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p><img src="/2019/04/13/Java容器/Iterable.png" alt></p><p>Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。</p><p>从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"a"</span>);</span><br><span class="line">list.add(<span class="string">"b"</span>);</span><br><span class="line"><span class="keyword">for</span> (String item : list) &#123;<span class="comment">//增强for循环就是通过Collection的Iterator对象遍历元素</span></span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>java.util.Arrays#asList() 可以把数组类型转换为 List 类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@SafeVarargs</span><br><span class="line">public static &lt;T&gt; List&lt;T&gt; asList(T... a)</span><br></pre></td></tr></table></figure><p>应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = &#123;1, 2, 3&#125;;</span><br><span class="line">List list = Arrays.asList(arr);</span><br></pre></td></tr></table></figure><p>也可以使用以下方式调用 asList()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);<span class="comment">//自动装箱</span></span><br></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><ul><li>实现了RandomAccess接口，支持快速存取访问</li><li>实现了Cloneable接口，支持克隆</li><li>实现了java.io.Serializable，支持序列化与反序列化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><h4 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;   <span class="comment">//ArrayList底层由Obiect数组实现</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;<span class="comment">//elementData中实际存放元素的个数</span></span><br></pre></td></tr></table></figure><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123; <span class="comment">//传入指定容量</span></span><br><span class="line">        <span class="keyword">super</span>();  <span class="comment">//调用父类构造器</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)  <span class="comment">//如果指定容量小于0，抛出参数不合法异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果未指定容量则默认容量为10</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);<span class="comment">//调用ArrayList(int initialCapacity)&#123;&#125;构造器</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="modCount"><a href="#modCount" class="headerlink" title="modCount"></a>modCount</h4><p>modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p><p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。</p><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//新容量为旧容量的1.5倍</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)<span class="comment">//如果新容量仍然小于指定容量</span></span><br><span class="line">        newCapacity = minCapacity;<span class="comment">//新容量等于指定容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p>调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，ArrayList 删除元素的代价很高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);<span class="comment">//检查指定下标是否合理</span></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);  <span class="comment">//获得要删除的元素</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;  <span class="comment">//计算应移动的元素个数</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)  <span class="comment">//如果需要移动的元素个数大于0,进行移动操作 </span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// 将数组最后一个元素设为null</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;  <span class="comment">//返回被删除的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;  <span class="comment">//记录操作前的modCount值</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);  <span class="comment">//写出数组大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//按正确顺序写出所有元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;  <span class="comment">//如果序列化后modCount的值发生了改变，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取大小和任何</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入容量</span></span><br><span class="line">    s.readInt(); <span class="comment">// 忽略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//类似clone()，根据大小而不是容量分配数组</span></span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// 按指定顺序写入所有元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="与-ArrayList-的比较"><a href="#与-ArrayList-的比较" class="headerlink" title="与 ArrayList 的比较"></a>与 ArrayList 的比较</h4><ul><li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</li><li>Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。</li></ul><h4 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h4><p>可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; synList = Collections.synchronizedList(list);  <span class="comment">//需要传入普通List对象</span></span><br></pre></td></tr></table></figure><p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p><p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p><p>写操作结束之后需要把原始数组指向新的复制数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();  <span class="comment">//写操作之前加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();  </span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);  <span class="comment">//复制数组</span></span><br><span class="line">        newElements[len] = e;  <span class="comment">//将e添加到复制数组的末尾</span></span><br><span class="line">        setArray(newElements);  <span class="comment">//将原始数组指向新的复制数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();  <span class="comment">//不管写操作是否成功,最后都释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p><strong>优点</strong>：CopyOnWriteArrayList 在<strong>写操作的同时允许读操作</strong>，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p><p><strong>缺陷</strong>：</p><ul><li><strong>内存占用</strong>：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li><li><strong>数据不一致</strong>：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li></ul><p><strong>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景</strong></p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><h4 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h4><p>基于双向链表实现，使用 Node 存储链表节点信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个链表存储了 first 和 last 指针：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/13/Java容器/LinkedList.png" alt></p><h4 id="与-ArrayList-的比较-1"><a href="#与-ArrayList-的比较-1" class="headerlink" title="与 ArrayList 的比较"></a>与 ArrayList 的比较</h4><ul><li>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现；</li><li>ArrayList 支持随机访问，LinkedList 不支持；</li><li>LinkedList 在任意位置添加删除元素更快。</li></ul><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>常用API</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>final int hash(Object k)</td><td>由Key的hashCode计算hash</td></tr><tr><td>public V put(Object key, Object value)</td><td>向HashMap中添加键值对</td></tr><tr><td>public V get(Object key)</td><td>由指定的key得到键值对</td></tr><tr><td>public boolean containsKey(Object key)</td><td>判断HashMap中是否包含键值对key</td></tr><tr><td>public V remove(Object key)</td><td>移除键值对</td></tr><tr><td>public void clear()</td><td>清空HashMap</td></tr><tr><td>…</td></tr></tbody></table><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>内部包含了一个 <strong>Entry 类型</strong>(键值对)的数组 table。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Entry[] table;</span><br></pre></td></tr></table></figure><p>Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即<strong>数组中的每个位置被当成一个桶，一个桶存放一个链表</strong>。HashMap 使用<strong>拉链法</strong>来解决冲突，同一个链表中存放<strong>哈希值相同</strong>的 Entry。</p><p><img src="/2019/04/13/Java容器/HashMap.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;  <span class="comment">//key只能读取,不能更改,设置为常量</span></span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;  <span class="comment">//指向下一个键值对</span></span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;  <span class="comment">//注意:这里将当前键值对指向传入的键值对</span></span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写equals()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))<span class="comment">//如果o不是Map.Entry类型的实例，直接返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry e = (Map.Entry)o;  <span class="comment">//将o强转为Map.Entry类型</span></span><br><span class="line">        <span class="comment">//分别获得当前对象与待比较对象的key</span></span><br><span class="line">        Object k1 = getKey();</span><br><span class="line">        Object k2 = e.getKey();</span><br><span class="line">        <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">            <span class="comment">//如果两对象的key为'=='或者等价,再分别获得两对象的value</span></span><br><span class="line">            Object v1 = getValue();</span><br><span class="line">            Object v2 = e.getValue();</span><br><span class="line">            <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                <span class="comment">//如果两对象的value为'=='或者等价,返回true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写hashCode()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写toString</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS : 从 JDK 1.8 开始，一个桶存储的链表长度大于 8 时会将链表转换为红黑树</p><h3 id="2-拉链法的工作原理"><a href="#2-拉链法的工作原理" class="headerlink" title="2. 拉链法的工作原理"></a>2. 拉链法的工作原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"K1"</span>, <span class="string">"V1"</span>);</span><br><span class="line">map.put(<span class="string">"K2"</span>, <span class="string">"V2"</span>);</span><br><span class="line">map.put(<span class="string">"K3"</span>, <span class="string">"V3"</span>);</span><br></pre></td></tr></table></figure><ul><li><p>新建一个 HashMap，默认大小为 16；</p></li><li><p>插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。</p></li><li><p>插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。</p></li><li><p>插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 &lt;K2,V2&gt; 前面。</p><p>(<strong>注意</strong>:K3虽然与K2的hashCode和桶下表相同，但他们的value不同，而根据HashMap的equals()方法，<strong>两个等价键值对必须key和value同时等价</strong>，所以K2与K3是不同的，这意味着K3能在K2已经存在的情况下顺利地插入桶下标为6的链表中)</p></li></ul><p>–-应该注意到链表的插入是以<strong>头插法方式</strong>进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在<strong>链表头部</strong>。</p><p>查找需要分成两步进行：</p><ul><li>计算<strong>键值对所在的桶</strong>；</li><li>在链表上<strong>顺序查找</strong>，时间复杂度显然和链表的长度成正比。</li></ul><p><img src="/2019/04/13/Java容器/HashMapSelect.png" alt></p><h4 id="计算-hash-值"><a href="#计算-hash-值" class="headerlink" title="计算 hash 值"></a>计算 hash 值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    This function ensures that hashCodes that differ only by</span><br><span class="line">    constant multiples at each bit position have a bounded</span><br><span class="line">    <span class="function">number of <span class="title">collisions</span> <span class="params">(approximately <span class="number">8</span> at <span class="keyword">default</span> load factor)</span>.</span></span><br><span class="line"><span class="function">    h ^</span>= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="确定桶下标"><a href="#确定桶下标" class="headerlink" title="确定桶下标"></a>确定桶下标</h4><p>很多操作都需要先确定一个键值对所在的桶下标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = hash(key);</span><br><span class="line"><span class="keyword">int</span> i = indexFor(hash, table.length);</span><br></pre></td></tr></table></figure><h4 id="put-操作-插入键值对"><a href="#put-操作-插入键值对" class="headerlink" title="put 操作(插入键值对)"></a>put 操作(插入键值对)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 键为 null 单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);  <span class="comment">//通过hash方法对key的hashCode（）进行二次加工。减少碰撞</span></span><br><span class="line">    <span class="comment">// 确定桶下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;  <span class="comment">//for循环顺序便利桶下表为i的链表</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);  <span class="comment">//记录一下</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;   <span class="comment">//modcount与线程安全有关，在使用迭代器遍历HashMap时，一旦modCount发生变化就抛出异常</span></span><br><span class="line">    <span class="comment">// 如果没有找到,插入新键值对</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果找到key为null的键值对,直接更新该键值对</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果HashMap的元素个数超过了最大容量并且桶下表不为null</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);  <span class="comment">//扩容</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;  <span class="comment">//得到hash值</span></span><br><span class="line">        bucketIndex = indexFor(hash, table.length);  <span class="comment">//得到桶下标</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);  <span class="comment">//调用插入键值对方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">// 头插法，链表头部指向新的键值对</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);  <span class="comment">//调用Entry的构造方法,构造方法中的next = n 使 table[bucketIndex]自动指向e</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS : 构造方法</p><pre><code>//构造方法Entry(int h, K k, V v, Entry&lt;K,V&gt; n) {    value = v;    next = n;  //注意:这里将当前键值对指向传入的键值对    key = k;    hash = h;}</code></pre><h4 id="get操作-通过key获得键值对"><a href="#get操作-通过key获得键值对" class="headerlink" title="get操作(通过key获得键值对)"></a>get操作(通过key获得键值对)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">return</span> getForNullKey();  </span><br><span class="line">    <span class="keyword">int</span> hash = hash(key)；  <span class="comment">//计算hash值</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);  <span class="comment">//得到桶下标</span></span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>;e = e.next)&#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span>(e.hash == hash &amp;&amp; ((k = e.key) == key || k.equals(key)))&#123;</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      modCount++;</span><br><span class="line">      Entry[] tab = table;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; i++)</span><br><span class="line">         tab[i] = <span class="keyword">null</span>;  <span class="comment">//直接将每个table置为null，等待GC释放空间</span></span><br><span class="line">         size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap的其他方法实现方式都类似，就不再一一列举了。</p><h4 id="HashMap与-HashTable-的比较"><a href="#HashMap与-HashTable-的比较" class="headerlink" title="HashMap与 HashTable 的比较"></a>HashMap与 HashTable 的比较</h4><ul><li>HashTable 使用 synchronized 来进行同步。</li><li>HashMap 可以插入键为 null 的 Entry。</li><li>HashMap 的迭代器是 fail-fast 迭代器。</li><li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li></ul><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><h4 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 <strong>ConcurrentHashMap 采用了分段锁</strong>（Segment），<strong>每个分段锁维护着几个桶</strong>（HashEntry），<strong>多个线程可以同时访问不同分段锁上的桶</strong>，从而使其<strong>并发度更高</strong>（并发度就是 Segment 的个数(Segment 继承自 ReentrantLock)）。</p><p>默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/13/Java容器/ConcurrentHashMap.png" alt></p><h4 id="size-操作"><a href="#size-操作" class="headerlink" title="size 操作"></a>size 操作</h4><p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure><p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p><p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。</p><p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。</p><p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p><h4 id="3-JDK-1-8-的改动"><a href="#3-JDK-1-8-的改动" class="headerlink" title="3. JDK 1.8 的改动"></a>3. JDK 1.8 的改动</h4><p>JDK 1.7 使用<strong>分段锁机制</strong>来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。</p><p>JDK 1.8 使用了 <strong>CAS 操作</strong>来支持更高的并发度，在 CAS 操作失败时使用<strong>内置锁 synchronized</strong>。</p><p>并且 JDK 1.8 的实现也在链表过长时会转换为<strong>红黑树</strong>。</p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><h4 id="存储结构-2"><a href="#存储结构-2" class="headerlink" title="存储结构"></a>存储结构</h4><p>继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p>内部维护了一个<strong>双向链表</strong>，用来维护<strong>插入顺序</strong>或者 <strong>LRU 顺序</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双向链表的头节点</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"><span class="comment">//双向链表的尾节点</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br></pre></td></tr></table></figure><p>accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure><p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="afterNodeAccess"><a href="#afterNodeAccess" class="headerlink" title="afterNodeAccess()"></a>afterNodeAccess()</h4><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p><h4 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion()"></a>afterNodeInsertion()</h4><p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。</p><p>evict 只有在构建 Map 的时候才为 false，在这里为 true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a>LRU 缓存</h4><p>以下是使用 LinkedHashMap 实现的一个 LRU 缓存：</p><ul><li>设定最大缓存空间 MAX_ENTRIES 为 3；</li><li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；</li><li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ENTRIES = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; MAX_ENTRIES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LRUCache() &#123;</span><br><span class="line">        <span class="keyword">super</span>(MAX_ENTRIES, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LRUCache&lt;Integer, String&gt; cache = <span class="keyword">new</span> LRUCache&lt;&gt;();</span><br><span class="line">    cache.put(<span class="number">1</span>, <span class="string">"a"</span>);</span><br><span class="line">    cache.put(<span class="number">2</span>, <span class="string">"b"</span>);</span><br><span class="line">    cache.put(<span class="number">3</span>, <span class="string">"c"</span>);</span><br><span class="line">    cache.get(<span class="number">1</span>);</span><br><span class="line">    cache.put(<span class="number">4</span>, <span class="string">"d"</span>);</span><br><span class="line">    System.out.println(cache.keySet());</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><h4 id="存储结构-3"><a href="#存储结构-3" class="headerlink" title="存储结构"></a>存储结构</h4><p>WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。</p><p>WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="ConcurrentCache"><a href="#ConcurrentCache" class="headerlink" title="ConcurrentCache"></a>ConcurrentCache</h3><p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。</p><p>ConcurrentCache 采取的是分代缓存：</p><ul><li>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）；</li><li>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。</li><li>当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。</li><li>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; eden;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; longterm;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentCache</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.eden = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(size);</span><br><span class="line">        <span class="keyword">this</span>.longterm = <span class="keyword">new</span> WeakHashMap&lt;&gt;(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">        V v = <span class="keyword">this</span>.eden.get(k);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">            v = <span class="keyword">this</span>.longterm.get(k);</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">this</span>.eden.put(k, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.eden.size() &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">this</span>.longterm.putAll(<span class="keyword">this</span>.eden);</span><br><span class="line">            <span class="keyword">this</span>.eden.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.eden.put(k, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明 : 本文章借鉴于GitHub上，本人只是根据自身学习情况做了一些删改，并添加了一些自己的理解</p><p>原文链接 : <a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java容器&quot;&gt;&lt;a href=&quot;#Java容器&quot; class=&quot;headerlink&quot; title=&quot;Java容器&quot;&gt;&lt;/a&gt;Java容器&lt;/h1&gt;&lt;h2 id=&quot;1-概览&quot;&gt;&lt;a href=&quot;#1-概览&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
    
      <category term="JavaSE" scheme="https://RookieQI.github.io/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JavaObject类详解</title>
    <link href="https://RookieQI.github.io/2019/04/13/JavaObject%E7%B1%BB%E8%AF%A6%E8%A7%A3/"/>
    <id>https://RookieQI.github.io/2019/04/13/JavaObject类详解/</id>
    <published>2019-04-13T15:56:59.000Z</published>
    <updated>2019-04-15T13:16:25.490Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><h2 id="方法概览"><a href="#方法概览" class="headerlink" title="方法概览"></a>方法概览</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span><span class="comment">//返回对象的散列值</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span><span class="comment">//判断两对象是否等价</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span><span class="comment">//返回对象字符串形式</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; <span class="title">getClass</span><span class="params">()</span><span class="comment">//获得类型的class对象</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure><h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h3><h4 id="1-实现"><a href="#1-实现" class="headerlink" title="1.实现"></a>1.实现</h4><ul><li>检查是否为同一个对象的引用，如果是直接返回 true；</li><li>检查是否是同一个类型，如果不是，直接返回 false；</li><li>将 Object 对象进行转型；</li><li>判断每个关键域是否相等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EqualExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//如果是同一对象的引用,返回ture</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//如果o为null或者this对象的类型与o的类型不同,返回false</span></span><br><span class="line"></span><br><span class="line">        EqualExample that = (EqualExample) o;<span class="comment">//将o转型为EqualExample</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对每个关键域进行比较</span></span><br><span class="line">        <span class="keyword">if</span> (x != that.x) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (y != that.y) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> z == that.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-equals-与-“-”-运算符的区别"><a href="#2-equals-与-“-”-运算符的区别" class="headerlink" title="2.equals()与 “==” 运算符的区别"></a>2.equals()与 “==” 运算符的区别</h4><p>表格表示 :</p><table><thead><tr><th></th><th>基本类型</th><th>引用类型</th></tr></thead><tbody><tr><td>equals()方法</td><td>没有equals()方法</td><td>判断引用的类型是否等价</td></tr><tr><td>“==”运算符</td><td>判断两值是否相等</td><td>判断两个变量是否引用同一对象</td></tr></tbody></table><p>代码示例 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// x与y所引用的对象等价,返回true</span></span><br><span class="line">System.out.println(x == y);      <span class="comment">// x与y引用的是不同对象,返回false</span></span><br></pre></td></tr></table></figure><h4 id="3-hashCode"><a href="#3-hashCode" class="headerlink" title="3.hashCode()"></a>3.hashCode()</h4><p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</p><h4 id="4-toString"><a href="#4-toString" class="headerlink" title="4.toString()"></a>4.toString()</h4><p>返回对象的字符串形式，一般需要在子类中重写</p><p>默认返回 ClassName@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p><p>声明 : 本文章借鉴于GitHub上，本人只是根据自身学习情况做了一些删改，并添加了一些自己的理解</p><p>原文链接 : <a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Object类&quot;&gt;&lt;a href=&quot;#Object类&quot; class=&quot;headerlink&quot; title=&quot;Object类&quot;&gt;&lt;/a&gt;Object类&lt;/h1&gt;&lt;h2 id=&quot;方法概览&quot;&gt;&lt;a href=&quot;#方法概览&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="JavaSE" scheme="https://RookieQI.github.io/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>继承与多态</title>
    <link href="https://RookieQI.github.io/2019/04/13/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/"/>
    <id>https://RookieQI.github.io/2019/04/13/继承与多态/</id>
    <published>2019-04-13T03:52:40.000Z</published>
    <updated>2019-04-13T13:02:48.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java继承与多态"><a href="#Java继承与多态" class="headerlink" title="Java继承与多态"></a>Java继承与多态</h1><h2 id="1-继承"><a href="#1-继承" class="headerlink" title="1.继承"></a>1.继承</h2><p>java只支持单继承</p><h3 id="2-super关键字"><a href="#2-super关键字" class="headerlink" title="2.super关键字"></a>2.super关键字</h3><p>super 关键字的功能：</p><ul><li>与this不同，this表示当前对象，super表示父类对象</li><li>调用父类中声明为 private 的变量。</li><li>调用已经覆盖了的方法。</li><li>作为方法名表示父类构造方法。</li></ul><h4 id="调用隐藏变量和被覆盖的方法"><a href="#调用隐藏变量和被覆盖的方法" class="headerlink" title="调用隐藏变量和被覆盖的方法"></a>调用隐藏变量和被覆盖的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String str = <span class="string">"学无止境"</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStr</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> str; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">learn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"人可以靠学习充实自己"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="meta">@OverRide</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">learn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.learn();  <span class="comment">// 调用父类的方法</span></span><br><span class="line">        <span class="comment">// 通过 getter 方法调用父类隐藏变量</span></span><br><span class="line">        System.out.println(<span class="string">"Please remember: "</span> + <span class="keyword">super</span>.getDesc());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.learn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">人可以靠学习充实自己</span></span><br><span class="line"><span class="comment">Please remember:学无止境</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>learn() 方法也可以定义在某些祖先类中，Java 具有追溯性，会一直向上找，直到找到该方法为止。</li><li>通过 super 调用父类的隐藏变量，必须要在父类中声明 getter 方法，因为声明为 private 的数据成员对子类是不可见的。</li></ul><h3 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h3><p><strong>1. 重写（Override）</strong></p><p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</p><p>下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：</p><ul><li><p>重写使用 @Override 注解</p></li><li><p>子类方法访问权限为 public，大于父类的 protected。</p></li><li>子类的返回类型为 ArrayList，是父类返回类型 List 的子类。</li><li>子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List&lt;Integer&gt; <span class="title">func</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">func</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 重载（Overload）</strong></p><p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</p><p>需要特别注意的是，返回值不同，其它都相同不算是重载。</p><h2 id="2-多态"><a href="#2-多态" class="headerlink" title="2.多态"></a>2.多态</h2><h3 id="多态的定义"><a href="#多态的定义" class="headerlink" title="多态的定义"></a>多态的定义</h3><p>多态是指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）</p><h3 id="实现多态的技术"><a href="#实现多态的技术" class="headerlink" title="实现多态的技术"></a>实现多态的技术</h3><p>实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法</p><h3 id="多态的作用"><a href="#多态的作用" class="headerlink" title="多态的作用"></a>多态的作用</h3><p>消除类型之间的耦合关系</p><h3 id="多态存在的必要条件"><a href="#多态存在的必要条件" class="headerlink" title="多态存在的必要条件"></a>多态存在的必要条件</h3><ul><li>要有继承</li><li>要有重写</li><li>父类引用指向子类对象</li></ul><h3 id="Java中多态的实现方式"><a href="#Java中多态的实现方式" class="headerlink" title="Java中多态的实现方式"></a>Java中多态的实现方式</h3><p>实现接口，继承父类方法进行重写，同一个类中进行方法重载</p><h3 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h3><p>作用：java 中的instanceof运算符通过返回一个布尔值来指出，这个对象是否是这个特定类或者是它的子类的一个实例</p><p>该运算符语法: Object object.intanceof(Class classname/Interface interfacename),返回值有以下结果:</p><ul><li>如果对象object是类Classname或者其子类的实例,返回true;</li><li>如果对象object实现了interfacename,返回true;</li><li>其他情况返回false</li></ul><p>一个简单的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Learn</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">learn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Learn</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">learn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"一个人在学习..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">learn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"一个学生在学习..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        People people = <span class="keyword">new</span> Student();<span class="comment">//定义一个实际类型为Student的引用people</span></span><br><span class="line">        <span class="keyword">if</span>(people <span class="keyword">instanceof</span> Object) &#123; System.out.println(<span class="string">"people是一个对象"</span>);&#125;<span class="comment">//true，people是Object的</span></span><br><span class="line">        <span class="keyword">if</span>(people <span class="keyword">instanceof</span> People) &#123; System.out.println(<span class="string">"people是一个人"</span>);&#125;  <span class="comment">//true,people是People的子类</span></span><br><span class="line">        <span class="keyword">if</span>(people <span class="keyword">instanceof</span> Student) &#123;System.out.println(<span class="string">"people是一个学生"</span>);&#125;<span class="comment">//true,people本身是Student类的对象</span></span><br><span class="line">        <span class="keyword">if</span>(people <span class="keyword">instanceof</span> Teacher) &#123;System.out.println(<span class="string">"people是一个教室"</span>);&#125;<span class="comment">//false,people与Teather都是People的子类,属于平行关系</span></span><br><span class="line">        <span class="keyword">if</span>(people <span class="keyword">instanceof</span> Learn)  &#123;System.out.println(<span class="string">"people可以学习"</span>)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">people是一个对象</span><br><span class="line">people是一个人</span><br><span class="line">people是一个学生</span><br><span class="line">people可以学习</span><br></pre></td></tr></table></figure><h3 id="多态对象的类型转换"><a href="#多态对象的类型转换" class="headerlink" title="多态对象的类型转换"></a>多态对象的类型转换</h3><p>假设有以下继承关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A animal is shouting..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"wang!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"miao!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-安全的向上转型"><a href="#1-安全的向上转型" class="headerlink" title="1.安全的向上转型"></a>1.安全的向上转型</h4><p>继承链下级类型的向上级转型，不存在风险，多态的一种体现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    Dog dog = new Dog();</span><br><span class="line">    Animal animal = dog;//发生了隐式的向上转型</span><br><span class="line">    //向上转型会损失一些数据与方法，例如animal将无法访问Dog类的新增方法，只能访问</span><br><span class="line">    Dog类中从Animal类中继承来的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不安全的强制转型"><a href="#不安全的强制转型" class="headerlink" title="不安全的强制转型"></a>不安全的强制转型</h4><p>继承链上次的类型向下级转型，存在风险</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Animal animal = <span class="keyword">new</span> Dog();</span><br><span class="line">    Cat cat = (Cat)animal;<span class="comment">//这里能顺利通过编译,因为编译器会将animal看作Animala类型的引用,但在运行期,animal的实际类型被确定为Dog,将Dog类型强行转换为Cat类型会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用instanceof进行安全的强制类型转换"><a href="#使用instanceof进行安全的强制类型转换" class="headerlink" title="使用instanceof进行安全的强制类型转换"></a>使用instanceof进行安全的强制类型转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Dog();<span class="comment">//代码1</span></span><br><span class="line">        animal.shout();<span class="comment">//根据多态,Animal类型引用animal可以调用Dog类对象的shout()方法</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        但有一点值得注意，由于多态的动态绑定，animal的实际类型是在运行时才确定的，</span></span><br><span class="line"><span class="comment">        也就是说，当我们无法看见代码1时,我们就无法事先知道animal到底指向的是</span></span><br><span class="line"><span class="comment">        Dog对象还是Cat对象,此时若贸然执行animal.shout(),执行的结果必定也是未知的(很简单，如果animal实际对象类型是Dog，则输出"wang!",如果是Cat,则执行"miao!",但我们并不知道实际对象类型)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">/*为了解决上述情况，我们可以在执行animal.shout()语句前，先用instanceof运算符</span></span><br><span class="line"><span class="comment">        判断出animal的类型，再根据相应的类型执行相应的动作*/</span></span><br><span class="line">        <span class="keyword">if</span>(animal <span class="keyword">instanceof</span> Dog)&#123;<span class="comment">//如果animal是Dog类的实例</span></span><br><span class="line">            Dog dog = (Dog)animal;<span class="comment">//将animal强制转型为Dog类型</span></span><br><span class="line">            dog1.shout();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(animal <span class="keyword">instanceof</span> Cat)&#123;<span class="comment">//如果animal是Cat类的实例</span></span><br><span class="line">            Cat cat = (Cat)amimal; <span class="comment">//将animal强制转型为Cat类型</span></span><br><span class="line">            cat.shout();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*执行结果</span></span><br><span class="line"><span class="comment">wang!</span></span><br><span class="line"><span class="comment">wang!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java继承与多态&quot;&gt;&lt;a href=&quot;#Java继承与多态&quot; class=&quot;headerlink&quot; title=&quot;Java继承与多态&quot;&gt;&lt;/a&gt;Java继承与多态&lt;/h1&gt;&lt;h2 id=&quot;1-继承&quot;&gt;&lt;a href=&quot;#1-继承&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="JAVA" scheme="https://RookieQI.github.io/categories/JAVA/"/>
    
    
      <category term="JavaSE" scheme="https://RookieQI.github.io/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>博客的起点</title>
    <link href="https://RookieQI.github.io/2019/04/12/%E5%8D%9A%E5%AE%A2%E4%BB%8B%E7%BB%8D/"/>
    <id>https://RookieQI.github.io/2019/04/12/博客介绍/</id>
    <published>2019-04-12T13:56:59.000Z</published>
    <updated>2019-04-15T13:54:25.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作者的一些话"><a href="#作者的一些话" class="headerlink" title="#作者的一些话"></a>#作者的一些话</h2><h4 id="您好-欢迎您浏览本博客-我是本博客的作者91MrQi，如果您也是一位编程的爱好者-我想我们可以做朋友…"><a href="#您好-欢迎您浏览本博客-我是本博客的作者91MrQi，如果您也是一位编程的爱好者-我想我们可以做朋友…" class="headerlink" title="您好!欢迎您浏览本博客,我是本博客的作者91MrQi，如果您也是一位编程的爱好者,我想我们可以做朋友…"></a>您好!欢迎您浏览本博客,我是本博客的作者91MrQi，如果您也是一位编程的爱好者,我想我们可以做朋友…</h4><h2 id="以下是本博客所有文章的目录，您可以点击链接进入您想要浏览的文章"><a href="#以下是本博客所有文章的目录，您可以点击链接进入您想要浏览的文章" class="headerlink" title="以下是本博客所有文章的目录，您可以点击链接进入您想要浏览的文章"></a>以下是本博客所有文章的目录，您可以点击链接进入您想要浏览的文章</h2><p>知识繁多而复杂，在真正开始学习之前，我们应该知道我们究竟需要学什么，按照什么顺序学，我在这里整理了一套Java完整学习路线，强烈建议您在正式开始学习之前先熟悉以下Java的学习路线，再按照学习路线，分阶段地有条不紊地学习，祝你学习愉快!</p><p>正式学习前，请点击这里 : <a href="/2019/04/15/Java学习路线/#more">Java 完整学习路线</a></p><h3 id="JAVA-SE部分"><a href="#JAVA-SE部分" class="headerlink" title="JAVA SE部分"></a>JAVA SE部分</h3><ul><li>JAVA 概述</li><li><a href="/2019/04/12/Java基础语法与数据类型/#more">JAVA 基础语法与数据类型</a></li><li><a href="/2019/04/13/继承与多态/#more">JAVA 继承与多态</a></li><li><a href="/2019/04/13/JavaObject类详解/#more">JAVA Object类详解</a></li><li><a href="/2019/04/13/Java容器/#more">JAVA 容器</a></li><li>JAVA 异常</li><li>JAVA I/O</li><li>JAVA 泛型</li><li>JAVA 并发</li><li>JAVA 虚拟机</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;作者的一些话&quot;&gt;&lt;a href=&quot;#作者的一些话&quot; class=&quot;headerlink&quot; title=&quot;#作者的一些话&quot;&gt;&lt;/a&gt;#作者的一些话&lt;/h2&gt;&lt;h4 id=&quot;您好-欢迎您浏览本博客-我是本博客的作者91MrQi，如果您也是一位编程的爱好者-我想我们可以
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Typora基本用法</title>
    <link href="https://RookieQI.github.io/2019/04/12/Typora%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <id>https://RookieQI.github.io/2019/04/12/Typora基本用法/</id>
    <published>2019-04-12T13:56:59.000Z</published>
    <updated>2019-04-13T12:52:26.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Typora编辑器-—-书写即为美学"><a href="#Typora编辑器-—-书写即为美学" class="headerlink" title="Typora编辑器 —-书写即为美学"></a>Typora编辑器 —-书写即为美学</h1><p>官方网站:<a href>https://www.typora.io/</a></p><p>支持平台</p><ul><li>Windows</li><li>Linux</li><li>OSX</li></ul><p>特点:</p><ul><li>完美支持GitHub的Markdown语法;</li><li>人性化的书写方式:<ul><li>表格的书写、挪动;</li><li>图片、超链接、网页表格复制;</li><li>目录生成;</li></ul></li><li>支持LeTex公式书写;</li><li>支持Flowchart,Mermaid等流程图绘制;</li><li>emoji,高亮,备注,上标,下标等书写;</li><li>生成网页,pdf,图片,甚至word,LeTex等格式。</li></ul><h2 id="基本的带快捷键的Markdown书写演示"><a href="#基本的带快捷键的Markdown书写演示" class="headerlink" title="基本的带快捷键的Markdown书写演示"></a>基本的带快捷键的Markdown书写演示</h2><p><code>Ctrl+0</code>到<code>Ctrl4</code>:普通文本、一级~四级标题;</p><p><code>Ctrl+B</code> : 加粗,<strong>加粗测试</strong>;</p><p><code>Ctrl+I</code> : 斜体,<em>斜体测试</em>;</p><p><code>Ctrl+U</code>: 下划线,<u>下划线测试</u>；</p><p><code>Shift Alt+5</code>:  删除线,<del>删除线测试</del>；</p><p>单机一下  `  : 行内代码块;</p><p><code>Ctrl+K</code> : 超链接,<a href>超链接测试</a>;还支持文章内锚点,请<code>Ctrl</code>点击此处–&gt;<a href>第二节</a>；</p><p><code>Ctrl+T</code> :  表格,支持拖拽移动、网页端表格复制转换:</p><table><thead><tr><th style="text-align:center">标题</th><th style="text-align:center">数据一</th><th style="text-align:center">数据二</th></tr></thead><tbody><tr><td style="text-align:center">表格测试</td><td style="text-align:center">943</td><td style="text-align:center">baka</td></tr></tbody></table><p><code>Ctrl + Shift + Q</code>: 引用 ：</p><blockquote><p>连续按两下Enter可以退出引用</p><p>Enter+Enter</p></blockquote><p><code>Shift Ctrl I</code>: 图片:</p><p><img src="/2019/04/12/Typora基本用法/E:/ASUS\Documents\3dbe04558b5d31c54a9f559553ef8d579e4a28325cfc017ed6be7fbb59a4e59c.jpg" alt="有道"></p><h2 id="基本的不带快捷键Markdown书写演示"><a href="#基本的不带快捷键Markdown书写演示" class="headerlink" title="基本的不带快捷键Markdown书写演示"></a>基本的不带快捷键Markdown书写演示</h2><p><strong>部分功能需要在 <code>文件</code>- <code>偏好设置</code> 中开启才能使用 </strong></p><p>`连续输入<figure class="highlight plain"><figcaption><span>: </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class Hello&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>无序、有序、任务列表</strong> :</p><ul><li><p>JAVA</p></li><li><p>PYTHON</p><ul><li>CSS   <code>按下Tab可进入下一级列表</code></li><li>HTML</li></ul><p><code>双击Enter退出列表</code></p></li></ul><p>  <code>任务列表可以勾选选项</code></p><ul><li style="list-style: none"><input type="checkbox"> 游戏</li><li style="list-style: none"><input type="checkbox"> 女人</li><li style="list-style: none"><input type="checkbox" checked> 代码</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Typora编辑器-—-书写即为美学&quot;&gt;&lt;a href=&quot;#Typora编辑器-—-书写即为美学&quot; class=&quot;headerlink&quot; title=&quot;Typora编辑器 —-书写即为美学&quot;&gt;&lt;/a&gt;Typora编辑器 —-书写即为美学&lt;/h1&gt;&lt;p&gt;官方网站:&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVA基础语法与数据类型</title>
    <link href="https://RookieQI.github.io/2019/04/12/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    <id>https://RookieQI.github.io/2019/04/12/基本类型/</id>
    <published>2019-04-12T13:56:59.000Z</published>
    <updated>2019-04-15T13:17:25.696Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、基本类型"><a href="#一、基本类型" class="headerlink" title="一、基本类型"></a>一、基本类型</h2><table><thead><tr><th>byte/8</th><th>char/16</th></tr></thead><tbody><tr><td>short/16</td><td>int/32</td></tr><tr><td>float/32</td><td>long/64</td></tr><tr><td>boolean/</td></tr></tbody></table><h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer x = 2;     // 装箱</span><br><span class="line">int y = x;         // 拆箱</span><br></pre></td></tr></table></figure><h3 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h3><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p><ul><li>new Integer(123) 每次都会新建一个对象；</li><li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer x = new Integer(123);</span><br><span class="line">Integer y = new Integer(123);</span><br><span class="line">System.out.println(x == y);    // false,x与y为不同对象的引用</span><br><span class="line">Integer z = Integer.valueOf(123);</span><br><span class="line">Integer k = Integer.valueOf(123);</span><br><span class="line">System.out.println(z == k);   // true,x与y为缓冲池中同一对象的引用</span><br></pre></td></tr></table></figure><p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) //判断i是否在-128~127之间</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)]; //为true返回缓冲池中对象</span><br><span class="line">    return new Integer(i); //为false返回一个新对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p><p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer m = 123;</span><br><span class="line">Integer n = 123;</span><br><span class="line">System.out.println(m == n); // true</span><br></pre></td></tr></table></figure><p>基本类型对应的缓冲池如下：</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul><p>在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</p><h2 id="二、String"><a href="#二、String" class="headerlink" title="二、String"></a>二、String</h2><p>String在java中表示不可变字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span>//<span class="title">String</span>不可继承</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;<span class="comment">//value初始化之后不能再引用其他数组,保证String数据不可变</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> coder;<span class="comment">//指定编码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p><h3 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h3><p>字符串常量池(String Pool)保存所有字符串的字面量，这些字面量在编译时确定。</p><h4 id="intern-方法"><a href="#intern-方法" class="headerlink" title="intern()方法"></a>intern()方法</h4><p>当一个String对象调用intern()方法时,如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String(&quot;aaa&quot;);</span><br><span class="line">String s2 = new String(&quot;aaa&quot;);</span><br><span class="line">System.out.println(&quot;s1 == s2&quot;); false,s1,s2引用堆中不同对象</span><br><span class="line">String s3 = s1.intern(); StringPool中先添加字符串&quot;aaa&quot;,然后s3引用该字符串</span><br><span class="line">String s4 = s1.intern(); StringPool已经存在字符</span><br><span class="line">串&quot;aaa&quot;,s4直接引用该字符串</span><br><span class="line">System.out.println(s3==s4); true,s3,s4引用的是StringPool中同一个字符串&quot;aaa&quot;</span><br></pre></td></tr></table></figure><h4 id="字面量形式创建字符串"><a href="#字面量形式创建字符串" class="headerlink" title="字面量形式创建字符串"></a>字面量形式创建字符串</h4><p>如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中，区别于使用new在堆中创建对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s5 = &quot;bbb&quot;;StringPool新增字符串&quot;bbb&quot;</span><br><span class="line">String s6 = &quot;bbb&quot;;引用StringPool中的&quot;bbb&quot;</span><br><span class="line">System.out.println(s5 == s6);  // true</span><br></pre></td></tr></table></figure><h4 id="new-String-“abc”"><a href="#new-String-“abc”" class="headerlink" title="new String(“abc”)"></a>new String(“abc”)</h4><p>如果StringPool中没有“abc”，这种方式会创建两个字符串对象:</p><ul><li>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象 “abc”</li><li>堆中创建一个字符串对象“abc”。</li></ul><h4 id="String构造函数源码"><a href="#String构造函数源码" class="headerlink" title="String构造函数源码"></a>String构造函数源码</h4><p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="String，StringBuffer，StringBuilder"><a href="#String，StringBuffer，StringBuilder" class="headerlink" title="String，StringBuffer，StringBuilder"></a>String，StringBuffer，StringBuilder</h4><p><strong>1. 可变性</strong></p><ul><li>String 不可变</li><li>StringBuffer 和 StringBuilder 可变</li></ul><p><strong>2. 线程安全</strong></p><ul><li>String 不可变，因此是线程安全的</li><li>StringBuilder 线程不安全</li><li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li></ul><h2 id="三、运算"><a href="#三、运算" class="headerlink" title="三、运算"></a>三、运算</h2><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>隐式类型转换指的是低精度数据类型转换为转换为高精度数据类型,</p><p>不会损失精度，如short(16)–&gt; int(32)，int (32)–&gt; double(64)，数据类型的精度可以理解为在内存中占的字节长度。</p><table><thead><tr><th>byte/8</th><th>char/16</th></tr></thead><tbody><tr><td>short/16</td><td>int/32</td></tr><tr><td>float/32</td><td>long/64</td></tr><tr><td>boolean/</td></tr></tbody></table><h3 id="强制类型转换-向下转型"><a href="#强制类型转换-向下转型" class="headerlink" title="强制类型转换(向下转型)"></a>强制类型转换(向下转型)</h3><p>强制类型转换指的是将高精度数据类型强制转换为低精度数据类型，会损失精度，如int(32)–&gt;short(16)，double(64)–&gt;int(32）</p><ul><li>一个例子</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double value = 3.1416926;</span><br><span class="line">int value1 = (int) value; //double类型强制转换为int型</span><br></pre></td></tr></table></figure><p>可想而知，由于double类型为64位，而int类型为32位，用一个int类型变量去接收double类型变量，只能接收到低32位，而高32位的数据便丢失了，也就是损失了精度</p><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"a"</span>;</span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"a"</span>:</span><br><span class="line">        System.out.println(<span class="string">"aaa"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"b"</span>:</span><br><span class="line">        System.out.println(<span class="string">"bbb"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、关键字"><a href="#四、关键字" class="headerlink" title="四、关键字"></a>四、关键字</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><h4 id="1-final修饰数据"><a href="#1-final修饰数据" class="headerlink" title="1.final修饰数据"></a>1.final修饰数据</h4><p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p><ul><li>对于基本类型，final 使数值不变；</li><li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">1</span>; value的值将不能修改</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Student stu = <span class="keyword">new</span> Student();stu将不能引用其他Student对象</span><br><span class="line">stu.name=<span class="string">"傻狍子"</span>;  stu本身数据可以修改</span><br></pre></td></tr></table></figure><p><strong>2. final修饰方法</strong></p><p>声明方法不能被子类重写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final viod Method()&#123;&#125;//Method方法不能被重写</span><br></pre></td></tr></table></figure><p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p><p><strong>3. final修饰类</strong></p><p>声明类不允许被继承。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final class String&#123;&#125;//String类不可被继承</span><br></pre></td></tr></table></figure><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><strong>1. 静态变量</strong></p><ul><li>静态变量：直接属于类，在类初始化时被初始化，通过类名直接访问</li><li>实例变量：属于实例，与实例一起初始化与销毁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;         <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> studentNumber;  <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="keyword">int</span> age = student.getAge();</span><br><span class="line">        <span class="keyword">int</span> number =  Student.studentNumber; <span class="comment">//类名直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 静态方法</strong></p><p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p><p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> studentNumber;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getStudentNummber</span><span class="params">()</span></span>&#123;<span class="comment">//返回学生总数</span></span><br><span class="line">        <span class="keyword">return</span> studentNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 静态语句块</strong></p><p>静态语句块只在类初始化时运行一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"加载学生类"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 静态内部类</strong></p><p>非静态内部类依赖于外部类的实例，而静态内部类不需要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OuterClass outerClass = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        <span class="comment">//使用外部类对象.new 静态内部类()的语法来创建静态内部类对象</span></span><br><span class="line">        InnerClass innerClass = outerClass.new InnerClass(); </span><br><span class="line">        <span class="comment">//静态内部类可以直接创建</span></span><br><span class="line">        StaticInnerClass staticInnerClass = <span class="keyword">new</span> StaticInnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类不能访问外部类的非静态的变量和方法。</p><p><strong>5. 静态导包</strong></p><p>静态导入是 Java 5 的新增特性，用来导入类的静态变量和静态方法。</p><p>一般我们导入类都这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import packageName.className;  // 导入某个特定的类</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import packageName.*;  // 导入包中的所有类</span><br></pre></td></tr></table></figure><p>而静态导入可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import static packageName.className.methonName;  // 导入某个特定的静态方法</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import static packageName.className.*;  // 导入类中的所有静态成员</span><br></pre></td></tr></table></figure><p>导入后，可以在当前类中直接用方法名调用静态方法，不必再用 className.methodName 来访问。</p><p>对于使用频繁的静态变量和静态方法，可以将其静态导入。静态导入的好处是可以简化一些操作，例如输出语句 System.out.println(); 中的 out 就是 System 类的静态变量，可以通过 import static java.lang.System.*; 将其导入，下次直接调用 out.println() 就可以了。</p><p>请看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import static java.lang.System.*;</span><br><span class="line">import static java.lang.Math.random;</span><br><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        out.println(&quot;产生的一个随机数：&quot; + random());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>产生的一个随机数：0.05800891549018705</p><p><strong>6. 初始化顺序</strong></p><p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String staticField = <span class="string">"静态变量"</span>;<span class="comment">//最先执行</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"静态语句块"</span>);<span class="comment">//其次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String field = <span class="string">"实例变量"</span>;<span class="comment">//其次</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"普通语句块"</span>);<span class="comment">//其次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后才是构造函数的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InitialOrderTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"构造函数"</span>);<span class="comment">//最后执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在继承的情况下，初始化顺序为：</p><ul><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ul><p>声明 : 本文章借鉴于GitHub上，本人只是根据自身学习情况做了一些删改，并添加了一些自己的理解</p><p>原文链接 : <a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、基本类型&quot;&gt;&lt;a href=&quot;#一、基本类型&quot; class=&quot;headerlink&quot; title=&quot;一、基本类型&quot;&gt;&lt;/a&gt;一、基本类型&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;byte/8&lt;/th&gt;
&lt;th&gt;char/16&lt;/th&gt;
&lt;/t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVA基础语法与数据类型</title>
    <link href="https://RookieQI.github.io/2019/04/12/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://RookieQI.github.io/2019/04/12/Java基础语法与数据类型/</id>
    <published>2019-04-12T13:56:59.000Z</published>
    <updated>2019-04-15T13:16:52.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、基本类型"><a href="#一、基本类型" class="headerlink" title="一、基本类型"></a>一、基本类型</h2><table><thead><tr><th>byte/8</th><th>char/16</th></tr></thead><tbody><tr><td>short/16</td><td>int/32</td></tr><tr><td>float/32</td><td>long/64</td></tr><tr><td>boolean/</td></tr></tbody></table><h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer x = 2;     // 装箱</span><br><span class="line">int y = x;         // 拆箱</span><br></pre></td></tr></table></figure><h3 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h3><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p><ul><li>new Integer(123) 每次都会新建一个对象；</li><li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false,x与y为不同对象的引用</span></span><br><span class="line">Integer z = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">Integer k = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true,x与y为缓冲池中同一对象的引用</span></span><br></pre></td></tr></table></figure><p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) <span class="comment">//判断i是否在-128~127之间</span></span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)]; <span class="comment">//为true返回缓冲池中对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i); <span class="comment">//为false返回一个新对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p><p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer m = <span class="number">123</span>;</span><br><span class="line">Integer n = <span class="number">123</span>;</span><br><span class="line">System.out.println(m == n); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>基本类型对应的缓冲池如下：</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul><p>在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</p><h2 id="二、String"><a href="#二、String" class="headerlink" title="二、String"></a>二、String</h2><p>String在java中表示不可变字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span>//<span class="title">String</span>不可继承</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;<span class="comment">//value初始化之后不能再引用其他数组,保证String数据不可变</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> coder;<span class="comment">//指定编码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p><h3 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h3><p>字符串常量池(String Pool)保存所有字符串的字面量，这些字面量在编译时确定。</p><h4 id="intern-方法"><a href="#intern-方法" class="headerlink" title="intern()方法"></a>intern()方法</h4><p>当一个String对象调用intern()方法时,如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">System.out.println(<span class="string">"s1 == s2"</span>); <span class="keyword">false</span>,s1,s2引用堆中不同对象</span><br><span class="line">String s3 = s1.intern(); StringPool中先添加字符串<span class="string">"aaa"</span>,然后s3引用该字符串</span><br><span class="line">String s4 = s1.intern(); StringPool已经存在字符</span><br><span class="line">串<span class="string">"aaa"</span>,s4直接引用该字符串</span><br><span class="line">System.out.println(s3==s4); <span class="keyword">true</span>,s3,s4引用的是StringPool中同一个字符串<span class="string">"aaa"</span></span><br></pre></td></tr></table></figure><h4 id="字面量形式创建字符串"><a href="#字面量形式创建字符串" class="headerlink" title="字面量形式创建字符串"></a>字面量形式创建字符串</h4><p>如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中，区别于使用new在堆中创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s5 = <span class="string">"bbb"</span>;StringPool新增字符串<span class="string">"bbb"</span></span><br><span class="line">String s6 = <span class="string">"bbb"</span>;引用StringPool中的<span class="string">"bbb"</span></span><br><span class="line">System.out.println(s5 == s6);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="new-String-“abc”"><a href="#new-String-“abc”" class="headerlink" title="new String(“abc”)"></a>new String(“abc”)</h4><p>如果StringPool中没有“abc”，这种方式会创建两个字符串对象:</p><ul><li>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象 “abc”</li><li>堆中创建一个字符串对象“abc”。</li></ul><h4 id="String构造函数源码"><a href="#String构造函数源码" class="headerlink" title="String构造函数源码"></a>String构造函数源码</h4><p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="String，StringBuffer，StringBuilder"><a href="#String，StringBuffer，StringBuilder" class="headerlink" title="String，StringBuffer，StringBuilder"></a>String，StringBuffer，StringBuilder</h4><p><strong>1. 可变性</strong></p><ul><li>String 不可变</li><li>StringBuffer 和 StringBuilder 可变</li></ul><p><strong>2. 线程安全</strong></p><ul><li>String 不可变，因此是线程安全的</li><li>StringBuilder 线程不安全</li><li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li></ul><h2 id="三、运算"><a href="#三、运算" class="headerlink" title="三、运算"></a>三、运算</h2><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>隐式类型转换指的是低精度数据类型转换为转换为高精度数据类型,</p><p>不会损失精度，如short(16)–&gt; int(32)，int (32)–&gt; double(64)，数据类型的精度可以理解为在内存中占的字节长度。</p><table><thead><tr><th>byte/8</th><th>char/16</th></tr></thead><tbody><tr><td>short/16</td><td>int/32</td></tr><tr><td>float/32</td><td>long/64</td></tr><tr><td>boolean/</td></tr></tbody></table><h3 id="强制类型转换-向下转型"><a href="#强制类型转换-向下转型" class="headerlink" title="强制类型转换(向下转型)"></a>强制类型转换(向下转型)</h3><p>强制类型转换指的是将高精度数据类型强制转换为低精度数据类型，会损失精度，如int(32)–&gt;short(16)，double(64)–&gt;int(32）</p><ul><li>一个例子</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double value = 3.1416926;</span><br><span class="line">int value1 = (int) value; //double类型强制转换为int型</span><br></pre></td></tr></table></figure><p>可想而知，由于double类型为64位，而int类型为32位，用一个int类型变量去接收double类型变量，只能接收到低32位，而高32位的数据便丢失了，也就是损失了精度</p><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"a"</span>;</span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"a"</span>:</span><br><span class="line">        System.out.println(<span class="string">"aaa"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"b"</span>:</span><br><span class="line">        System.out.println(<span class="string">"bbb"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、关键字"><a href="#四、关键字" class="headerlink" title="四、关键字"></a>四、关键字</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><h4 id="1-final修饰数据"><a href="#1-final修饰数据" class="headerlink" title="1.final修饰数据"></a>1.final修饰数据</h4><p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p><ul><li>对于基本类型，final 使数值不变；</li><li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">1</span>; value的值将不能修改</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Student stu = <span class="keyword">new</span> Student();stu将不能引用其他Student对象</span><br><span class="line">stu.name=<span class="string">"傻狍子"</span>;  stu本身数据可以修改</span><br></pre></td></tr></table></figure><p><strong>2. final修饰方法</strong></p><p>声明方法不能被子类重写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> viod <span class="title">Method</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//Method方法不能被重写</span></span><br></pre></td></tr></table></figure><p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p><p><strong>3. final修饰类</strong></p><p>声明类不允许被继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span>&#123;&#125;<span class="comment">//String类不可被继承</span></span><br></pre></td></tr></table></figure><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><strong>1. 静态变量</strong></p><ul><li>静态变量：直接属于类，在类初始化时被初始化，通过类名直接访问</li><li>实例变量：属于实例，与实例一起初始化与销毁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;         <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> studentNumber;  <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="keyword">int</span> age = student.getAge();</span><br><span class="line">        <span class="keyword">int</span> number =  Student.studentNumber; <span class="comment">//类名直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 静态方法</strong></p><p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p><p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> studentNumber;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getStudentNummber</span><span class="params">()</span></span>&#123;<span class="comment">//返回学生总数</span></span><br><span class="line">        <span class="keyword">return</span> studentNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 静态语句块</strong></p><p>静态语句块只在类初始化时运行一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"加载学生类"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 静态内部类</strong></p><p>非静态内部类依赖于外部类的实例，而静态内部类不需要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OuterClass outerClass = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        <span class="comment">//使用外部类对象.new 静态内部类()的语法来创建静态内部类对象</span></span><br><span class="line">        InnerClass innerClass = outerClass.new InnerClass(); </span><br><span class="line">        <span class="comment">//静态内部类可以直接创建</span></span><br><span class="line">        StaticInnerClass staticInnerClass = <span class="keyword">new</span> StaticInnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类不能访问外部类的非静态的变量和方法。</p><p><strong>5. 静态导包</strong></p><p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.xxx.ClassName</span><br></pre></td></tr></table></figure><p><strong>6. 初始化顺序</strong></p><p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String staticField = <span class="string">"静态变量"</span>;<span class="comment">//最先执行</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"静态语句块"</span>);<span class="comment">//其次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String field = <span class="string">"实例变量"</span>;<span class="comment">//其次</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"普通语句块"</span>);<span class="comment">//其次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后才是构造函数的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InitialOrderTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"构造函数"</span>);<span class="comment">//最后执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在继承的情况下，初始化顺序为：</p><ul><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ul><h2 id="五、-面向对象基本特性"><a href="#五、-面向对象基本特性" class="headerlink" title="五、 面向对象基本特性"></a>五、 面向对象基本特性</h2><h3 id="1-继承"><a href="#1-继承" class="headerlink" title="1.继承"></a>1.继承</h3><p>java只支持单继承</p><h3 id="2-super关键字"><a href="#2-super关键字" class="headerlink" title="2.super关键字"></a>2.super关键字</h3><p>super 关键字的功能：</p><ul><li><p>与this不同，this表示当前对象，super表示父类对象</p></li><li><p>调用父类中声明为 private 的变量。</p></li><li>调用已经覆盖了的方法。</li><li>作为方法名表示父类构造方法。</li></ul><h4 id="调用隐藏变量和被覆盖的方法"><a href="#调用隐藏变量和被覆盖的方法" class="headerlink" title="调用隐藏变量和被覆盖的方法"></a>调用隐藏变量和被覆盖的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String str = <span class="string">"学无止境"</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStr</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> str; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">learn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"人可以靠学习充实自己"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="meta">@OverRide</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">learn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.learn();  <span class="comment">// 调用父类的方法</span></span><br><span class="line">        <span class="comment">// 通过 getter 方法调用父类隐藏变量</span></span><br><span class="line">        System.out.println(<span class="string">"Please remember: "</span> + <span class="keyword">super</span>.getDesc());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.learn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">人可以靠学习充实自己</span></span><br><span class="line"><span class="comment">Please remember:学无止境</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><p>learn() 方法也可以定义在某些祖先类中，Java 具有追溯性，会一直向上找，直到找到该方法为止。</p></li><li><p>通过 super 调用父类的隐藏变量，必须要在父类中声明 getter 方法，因为声明为 private 的数据成员对子类是不可见的。</p></li></ul><p>声明 : 本文章借鉴于GitHub上，本人只是根据自身学习情况做了一些删改，并添加了一些自己的理解</p><p>原文链接 : <a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、基本类型&quot;&gt;&lt;a href=&quot;#一、基本类型&quot; class=&quot;headerlink&quot; title=&quot;一、基本类型&quot;&gt;&lt;/a&gt;一、基本类型&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;byte/8&lt;/th&gt;
&lt;th&gt;char/16&lt;/th&gt;
&lt;/t
      
    
    </summary>
    
      <category term="JAVA" scheme="https://RookieQI.github.io/categories/JAVA/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://RookieQI.github.io/2019/04/11/hello-world/"/>
    <id>https://RookieQI.github.io/2019/04/11/hello-world/</id>
    <published>2019-04-11T12:59:19.885Z</published>
    <updated>2019-04-13T10:10:39.792Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="齐阳的个人博客主页"><a href="#齐阳的个人博客主页" class="headerlink" title="齐阳的个人博客主页"></a>齐阳的个人博客主页</h2><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
